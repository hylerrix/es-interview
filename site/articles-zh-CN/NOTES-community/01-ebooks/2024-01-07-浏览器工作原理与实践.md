
## (2024-01-07) 开篇词 | 参透了浏览器的工作原理，你就能解决80%的前端难题

* 太阳花，国内第一款双核浏览器 —— 基于 Chromium 和 IE
	* 2008 Chromium 开源
	* 如何在 Chromium 中集成 IE 模块
	* Chromium 的进程架构以及渲染流程
* 2011，盛大创新院，WebOS 的愿景是基于 WebKit 内核打造一个能和安卓并存的操作系统
	* 在团队中负责 HTML5 特性的实现，比如实现 Web Workers、Application Cache、LocalStorage、IndexedDB、CSS3 部分动画效果等
* 顺网科技，全国网吧使用的“F1 浏览器”，日启量达到 2000 万
	* 页面劫持？安全要求。千万启动量？加载速度和流畅度
* 浏览器时间
	* 1995 年，美国网景公司因“网景浏览器”的发布而快速崛起，之后网景试图开发一个依靠浏览器的网络操作系统。这引起了微软的注意和警惕，于是同年微软发布 Windows 95，并捆绑了 IE，大获成功，到 2002 年，微软就已经占据了浏览器市场 80% 的份额。
	* 直到 2008 年 Chrome 浏览器横空出世，这种垄断局面才算被打破。Chrome 浏览器完全颠覆了之前浏览器的架构设计，在速度和安全性上占据了绝对优势，市场份额占比剧增（据 StatCounter 2019 年的统计数据显示，Chrome 占据了 63% 市场份额）。在 2010 年底，Google 还推出了一款网络操作系统——ChromeOS。
* 浏览器三大进化路线
	* 应用程序 Web 化：云计算普及、HTML5 技术发展，大量应用（视频、音频、游戏）转向 B/S 架构
	* Web 应用移动化：但技术层面还有问题需要解决（比如，渲染流程过于复杂且性能不及原生应用、离线时用户无法使用、无法接收消息推送、移动端没有一级入口）
		* Google PWA 方案整合 Web 和本地程序各自的优势
	* Web 操作系统化：
		* 一是利用 Web 技术构建一个纯粹的操作系统，如 ChromeOS
		* 二是浏览器的底层结构往操作系统架构方向发展
			* Chrome 朝着 SOA 的方向演化，未来很多模块都会以服务的形式提供给上层应用使用；
			* 在浏览器中引入多种编程语言的支持，比如新支持的 WebAssembly；
			* 简化渲染流程，使得渲染过程更加直接高效；
			* 加大对系统设备特性的支持；提供对复杂 Web 项目开发的支持。
* 大量的高速渲染动画和快速交互的场景需求
	* 传统的 C++ 开发界面，很难按时交付，后期维护也会很麻烦
	* Web 方案可以降低开发成本，缩短交付周期
* 用户角度的性能要求：
	* 访问网站时，1s 看到内容
	* 点击按钮时，100ms 看到响应
	* 动画要达到 60fps
* 首屏的显示就涉及了 DNS、HTTP、DOM 解析、CSS 阻塞、JavaScript 阻塞等技术因素，其中一项没处理好就可能导致整个页面的延时。
* 从 2011 年到现在，前端技术出现了大爆炸式增长，各种新技术层出不穷。
	* Node.js 是前端发展的一个核心推动力。Node.js 是基于 Chrome 的 JavaScript 引擎 V8 来实现的，它的特点是可以脱离浏览器环境来执行 JavaScript
	* 随着脚本执行效率的提高、页面渲染性能的提升和开发工具链的完善，接下来的前端会进入一个相对平稳的阶段
* 前端技术是如何针对这些核心诉求做演进的？
	* 脚本执行速度：
		* 不断修复缺陷，ES6/ES7...，TypeScript
		* 颠覆性新技术：WebAssembly
	* 前端模块化开发：WebComponents（Shadow DOM/HTML Templates）
	* 渲染效率问题
		* 下一代布局方案 LayoutNG，渲染瘦身方案 Slim Paint
* 重新认识浏览器，并把网络、页面渲染、JavaScript、浏览器安全等知识串联起来，从而让你对整个前端体系有全新的认识

## (2024-01-07)  宏观视角下的浏览器（6讲）

### 01| Chrome架构：仅仅打开了1个页面，为什么有4个进程？

* 多进程架构学习——网络流程、页面渲染过程、JavaScript 执行流程、Web 安全理论
* Chrome
	* 因为 Chrome、微软的 Edge 以及国内的大部分主流浏览器，都是基于 Chromium 二次开发而来
	* Chrome 是 Google 的官方发行版，特性和 Chromium 基本一样，只存在一些产品层面差异；再加上 Chrome 是目前世界上使用率最高的浏览器，所以 Chrome 最具代表性。
* 打开一个页面，四个进程
	*  浏览器本身
	* 标签页
	* GPU 进程
	* 实用程序：Network Service
* 计算机中的并行处理就是同一时刻处理多个任务
	* 多线程可以并行处理任务，但是线程是不能单独存在的，它是由进程来启动和管理的
	* 一个进程就是一个程序的运行实例
	* 线程是依附于进程的，而进程中使用多线程并行处理能提升运算效率。
* 进程和线程之间的关系
	* 1. 进程中的任意一线程执行出错，都会导致整个进程的崩溃
	* 2. 线程之间共享进程中的数据。
	* 3. 当一个进程关闭之后，操作系统会回收进程所占用的内存。
		* 之前的 IE 浏览器，支持很多插件，而这些插件很容易导致内存泄漏，这意味着只要浏览器开着，内存占用就有可能会越来越多，但是当关闭浏览器进程时，这些内存就都会被系统回收掉。
	* 4. 进程之间的内容相互隔离。
		* 如果进程之间需要进行数据的通信，这时候，就需要使用用于进程间通信（IPC）的机制了。
		* Electron桌面应用中内部得也是chromium的内核，有两个进程，分别是Main主进程和Renderer渲染进程，两者的通信也是需要用到IPC (inter-process communication)
		* 进程之间数据相互隔离，因此进程间通信需要使用内核。内核开辟一块数据缓冲区域，将进程a的数据copy到缓冲区，b进程再将数据从缓冲区读取
* 单进程浏览器
	* 是指浏览器的所有功能模块都是运行在同一个进程里，这些模块包含了网络、插件、JavaScript 运行环境、渲染引擎和页面等。其实早在 2007 年之前，市面上浏览器都是单进程的。
	* 线程
		* 页面线程：页面渲染、页面展现、JavaScript 环境、插件
		* 网络线程
		* 其它线程
	* 特点
		* 不稳定：早期浏览器需要大量插件实现 Web 视频、Web 游戏等强大功能，但是插件最容易出问题；渲染引擎模块也不稳定，复杂的 JS 代码可能引起渲染引擎模块的崩溃
		* 不流畅：无限循环的脚本、页面内存的泄漏
		* 不安全：插件用 C/C++ 等代码编写，可以获取到操作系统的任意资源
* 多进程浏览器 - 2008 年 Chrome
	* Chrome 的页面是运行在单独的渲染进程中的，同时页面里的插件也是运行在单独的插件进程之中，而进程之间是通过 IPC 机制进行通信
	* 不稳定问题解决：当一个页面或者插件崩溃时，影响到的仅仅是当前的页面进程或者插件进程
	* 不流畅问题解决：
		* JavaScript 也是运行在渲染进程中的，所以即使 JavaScript 阻塞了渲染进程，影响到的也只是当前的渲染页面，而并不会影响浏览器和其他页面
		* 对于内存泄漏的解决方法那就更简单了，因为当关闭一个页面时，整个渲染进程也会被关闭，之后该进程所占用的内存都会被系统回收，这样就轻松解决了浏览器页面的内存泄漏问题。
	* 安全问题的解决：
		* 采用多进程架构的额外好处是可以使用安全沙箱，你可以把沙箱看成是操作系统给进程上了一把锁，沙箱里面的程序可以运行，但是不能在你的硬盘上写入任何数据，也不能在敏感位置读取任何数据，例如你的文档和桌面
		* Chrome 把插件进程和渲染进程锁在沙箱里面，这样即使在渲染进程或者插件进程里面执行了恶意程序，恶意程序也无法突破沙箱去获取系统权限。
* 目前的多进程架构
	* 1 个浏览器（Browser）主进程：主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。
	* 1 个 GPU 进程：其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。
	* 1 个网络（NetWork）进程：主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。
	* 多个渲染进程：核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。
	* 多个插件进程
* 多进程模型的缺点：更高的资源占用、更复杂的架构体系
* 未来面向服务的架构
	* Chrome 最终要把 UI、数据库、文件、设备、网络等模块重构为基础服务，类似操作系统底层服务
	* 同时 Chrome 还提供灵活的弹性架构，在强大性能设备上会以多进程的方式运行基础服务，但是如果在资源受限的设备上（如下图），Chrome 会将很多服务整合到一个进程中，从而节省内存占用。
* 问答
	* 感觉挺好奇的，单进程浏览器开多个页面，渲染线程也只有一个吗？感觉一个页面开一个线程不是更合理吗？
		* IE6时代，浏览器是单进程的，所有页面也都是运行在一个主线程中的，当时IE6就是这样设计，而且此时的IE6是单标签，也就是说一个页面一个窗口
		* 这时候，国内有很多国产浏览器，都是基于IE6来二次开发的，而IE6原生架构就是所有页面跑在单线程里面的，意味着，所有的页面都共享着同一套JavaScript运行环境，同样，对于存储Cookie也都是在一个线程里面操作的。
		* 而且这些国产浏览器由于需要，都采用多标签的形式，所以其中的一个标签页面的卡顿都会影响到整个浏览器。
	* 为什么Chrome中的一个页面假死不会影响到主窗口呢？
		* 这是因为chrome输出的实际上图片，然后浏览器端把图片贴到自己的窗口上去，在Chrome的渲染进程内，并没有一个渲染窗口，输出的只是图片，如果卡住了，顶多图片不更新了。

### 02|TCP协议：如何保证页面文件能被完整送达浏览器？


* “FP（First Paint）”，是指从页面加载到首次开始绘制的时长
	* 直接影响了用户的跳出率，更快的页面响应意味着更多的 PV、更高的参与度，以及更高的转化率
	* 不管你是使用 HTTP，还是使用 WebSocket，它们都是基于 TCP/IP 的
* 在网络中，一个文件通常会被拆分为很多数据包来进行传输，而数据包在传输过程中又有很大概率丢失或者出错。那么如何保证页面文件能被完整地送达浏览器呢？
	* “数据包如何送达主机”
	* “主机如何将数据包转交给应用”
	* “数据是如何被完整地送达应用程序”
* 1. IP：把数据包送达目的主机
	* IP 头是 IP 数据包开头的信息，包含 IP 版本、源 IP 地址、目标 IP 地址、生存时间等信息IP 是非常底层的协议，只负责把数据包传送到对方电脑，但是对方电脑并不知道把数据包交给哪个程序
* 2. UDP：把数据包送达应用程序
	* 通过端口号 UDP 就能把指定的数据包发送给指定的程序了
	* 和 IP 头一样，端口号会被装进 UDP 头里面，UDP 头再和原始数据包合并组成新的 UDP 数据包。UDP 头中除了目的端口，还有源端口号等信息。
	* 虽然 UDP 可以校验数据是否正确，但是对于错误的数据包，UDP 并不提供重发机制
	* 虽说 UDP 不能保证数据可靠性，但是传输速度却非常快，所以 UDP 会应用在一些关注速度、但不那么严格要求数据完整性的领域，如在线视频、互动游戏等。
* 3. TCP：把数据完整地送达应用程序
	* UDP 缺点：数据包容易丢失、数据包被拆分后不知道如何组装
	* TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议
		* 对于数据包丢失的情况，TCP 提供重传机制；
		* TCP 引入了数据包排序机制，用来保证把乱序的数据包组合成一个完整的文件。
	* TCP 是如何保证重传机制和数据包的排序功能的。
		* 一个完整的 TCP 连接的生命周期包括了“建立连接”“传输数据”和“断开连接”三个阶段。
		* 建立连接：在建立一个 TCP 连接时，客户端和服务器总共要发送三个数据包以确认连接的建立。Synchronous 建立联机；Acknowledgement 确认
		* 传输数据：
			* 接收端需要对每个数据包进行确认操作，也就是接收端在接收到数据包之后，需要发送确认数据包给发送端
			* 当发送端发送了一个数据包之后，在规定时间内没有接收到接收端反馈的确认消息，则判断为数据包丢失，并触发发送端的重发机制
			* 一个大的文件在传输过程中会被拆分成很多小的数据包，这些数据包到达接收端后，接收端会按照 TCP 头中的序号为其排序，从而保证组成完整的数据。
		* 断开连接：客户端 FIN -> 服务端 ACK。服务端 FIN -> 客户端 ACK
* 问答
	* 接收到http响应头中的content-type类型时就开始准备渲染进程了， 响应体数据一旦接受到便开始做DOM解析了！ 基于http不用担心数据包丢失的问题，因为丢包和重传都是在tcp层解决的。http能保证数据按照顺序接收的！

### 03 | HTTP请求流程：为什么很多站点第二次打开速度会很快？

* HTTP 是一种允许浏览器向服务器获取资源的协议，是 Web 的基础
* 常由浏览器发起请求，用来获取不同类型的文件，例如 HTML 文件、CSS 文件、JavaScript 文件、图片、视频等
* 浏览器端发起 HTTP 请求流程
	* 在真正发起网络请求之前，浏览器会先在浏览器缓存中查询是否有要请求的文件。
	* 其中，浏览器缓存是一种在本地保存资源副本，以供下次请求时直接使用的技术。
	* 当浏览器发现请求的资源已经在浏览器缓存中存有副本，它会拦截请求，返回该资源的副本，并直接结束请求，而不会再去源服务器重新下载。
		* 缓解服务器端压力，提升性能（获取资源的耗时更短了）；
		* 对于网站来说，缓存是实现快速资源加载的重要组成部分。
	* 域名映射为 IP 的系统就叫做“域名系统”，简称 DNS（Domain Name System）。
	* Chrome 有个机制，同一个域名同时最多只能建立 6 个 TCP 连接，如果在同一个域名下同时有 10 个请求发生，那么其中 4 个请求会进入排队等待状态，直至进行中的请求完成。
* 服务器端处理 HTTP 请求流程
	* 通常情况下，一旦服务器向客户端返回了请求数据，它就要关闭 TCP 连接。不过如果浏览器或者服务器在其头信息中加入了：Connection:Keep-Alive
	* 那么 TCP 连接在发送后将仍然保持打开状态，这样浏览器就可以继续通过同一个 TCP 连接发送请求。保持 TCP 连接可以省去下次请求时需要建立连接的时间，提升资源加载速度。
* 浏览器中的 HTTP 请求从发起到结束一共经历了如下八个阶段：构建请求、查找缓存、准备 IP 和端口、等待 TCP 队列、建立 TCP 连接、发起 HTTP 请求、服务器处理请求、服务器返回请求和断开连接。

### 04 | 导航流程：从输入URL到页面展示，这中间发生了什么？


* 整个过程需要各个进程之间的配合
	* 浏览器进程主要负责用户交互、子进程管理和文件储存等功能。
	* 网络进程是面向渲染进程和浏览器进程等提供网络下载功能。
	* 渲染进程的主要职责是把从网络下载的 HTML、JavaScript、CSS、图片等资源解析为可以显示和交互的页面。
		* 因为渲染进程所有的内容都是通过网络获取的，会存在一些恶意代码利用浏览器漏洞对系统进行攻击，所以运行在渲染进程里面的代码是不被信任的。这也是为什么 Chrome 会让渲染进程运行在安全沙箱里，就是为了保证系统的安全。
* 导航过程
	* 浏览器进程 -> URL -> 网络进程。
	* 网络进程 -> 发起真正的 URL 请求 -> 得到响应头 -> 将响应数据交给浏览器主进程。
	* 浏览器进程 -> 提交导航 CommitNavigation 消息到渲染进程
	* 渲染进程 -> 准备接收 HTML 数据，接收方式是直接和网络进程建立数据管道
	* 渲染进程 -> 确认提交 -> 浏览器进程
	* 浏览器进程 -> 收到确认提交 -> 移除之前文档，更新浏览器进程页面状态
* 过程
	* 1. 用户输入：
		* 判断是否是 URL 或者直接搜索
		* 输入 URL 并回车后，浏览器给当前页面一次执行 beforeunload 事件的机会
	* 2. URL 请求过程：
		* 通过进程间通信（IPC）把 URL 请求发送至网络进程
			* 看缓存
			* 获取 DNS 解析
			* 可选：建立 TLS 连接
			* 利用 IP 地址，建立 TCP 连接
		* 服务器接收到，生成响应数据（响应行、响应头、响应体）
		* 网络进程接收到
			* 解析响应头：301/302 重定向？读取 location 字段，开始重定向，一切重新开始
			* 响应数据类型处理：content-type
				* 如果是 application/octet-stream 通常浏览器按照下载类型处理
				* 不同 Content-Type 的后续处理流程也截然不同
				* 如果 Content-Type 字段的值被浏览器判断为下载类型，那么该请求会被提交给浏览器的下载管理器，同时该 URL 请求的导航流程就此结束。
				* 但如果是 HTML，那么浏览器则会继续进行导航流程。由于 Chrome 的页面渲染是运行在渲染进程中的，所以接下来就需要准备渲染进程了。
	* 3. 准备渲染进程
		* 默认情况下，Chrome 会为每个（新）页面分配一个渲染进程，也就是说，每打开一个新页面就会配套创建一个新的渲染进程
		* 同一站点（根域名和协议相同）下，且一个打开了另一个，使用一个渲染进程。策略叫 process-per-site-instance
	* 4. 提交文档——浏览器进程将网络进程接收到的 HTML 数据提交给渲染进程
		* 首先当浏览器进程接收到网络进程的响应头数据之后，便向渲染进程发起“提交文档”的消息；
		* 渲染进程接收到“提交文档”的消息后，会和网络进程建立传输数据的“管道”；
		* 等文档数据传输完成之后，渲染进程会返回“确认提交”的消息给浏览器进程；
		* 浏览器进程在收到“确认提交”的消息后，会更新浏览器界面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面。
* 问答
	* a 标签里 rel="noopener noreferrer" 就是告诉浏览器，新打开的子窗口不需要访问父窗口的任何内容，这是为了防止一些钓鱼网站窃取父窗口的信息。
	* 浏览器在打开新页面时，解析到含有noopener noreferrer时，就知道他们不需要共享页面内容，所以这时候浏览器就会让新链接在一个新页面中打开了。

### 05 | 渲染流程（上）：HTML、CSS和JavaScript，是如何变成页面的？

* 由于渲染机制过于复杂，所以渲染模块在执行过程中会被划分为很多子阶段，输入的 HTML 经过这些子阶段，最后输出像素。
* 按照渲染的时间顺序，流水线可分为如下几个子阶段：构建 DOM 树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成。
* 构建 DOM 树
	* 构建 DOM 树的输入内容是一个非常简单的 HTML 文件，然后经由 HTML 解析器解析，最终输出树状结构的 DOM。
	* DOM 和 HTML 内容几乎是一样的，但是和 HTML 不同的是，DOM 是保存在内存中树状结构，可以通过 JavaScript 来查询或修改其内容。
* 样式计算
	* 1. 把 CSS 转换为浏览器能够理解的结构
		* 当渲染引擎接收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构——styleSheets。
		* document.styleSheets
	* 2. 转换样式表中的属性值，使其标准化
		* 2em、blue、bold 等变成 32px、rgb(0,0,255)、700
	* 3. 计算出 DOM 树中每个节点的具体样式
		* 涉及到 CSS 的继承规则和层叠规则了。
		* CSS 继承就是每个 DOM 节点都包含有父节点的样式。
		* 层叠是 CSS 的一个基本特征，它是一个定义了如何合并来自多个源的属性值的算法。它在 CSS 处于核心地位，CSS 的全称“层叠样式表”正是强调了这一点。
		* 样式计算阶段的目的是为了计算出 DOM 节点中每个元素的具体样式，在计算过程中需要遵守 CSS 的继承和层叠两个规则。这个阶段最终输出的内容是每个 DOM 节点的样式，并被保存在 **ComputedStyle** 的结构内。
* 布局阶段
	* 1. 创建布局树
		* 算出 DOM 树中可见元素的几何位置，我们把这个计算过程叫做布局。
		* DOM 树中所有不可见的节点都没有包含到布局树中。
		* 过程
			* 遍历 DOM 树中的所有可见节点，并把这些节点加到布局树中；
			* 而不可见的节点会被布局树忽略掉，如 head 标签下面的全部内容，再比如 body.p.span 这个元素，因为它的属性包含 dispaly:none，所以这个元素也没有被包进布局树。
	* 2. 布局计算
		* 在执行布局操作的时候，会把布局运算的结果重新写回布局树中，所以布局树既是输入内容也是输出内容，这是布局阶段一个不合理的地方，因为在布局阶段并没有清晰地将输入内容和输出内容区分开来。
* 如果下载 CSS 文件阻塞了，会阻塞 DOM 树的合成吗？会阻塞页面的显示吗？
	* **阻塞DOM解析**：CSS通常不会阻塞DOM树的解析，但会阻塞其渲染。当浏览器遇到`<link>`标签引用外部CSS时，会暂停渲染，直到CSS下载并解析完成。
	- **阻塞DOM渲染**：浏览器需要等待CSS的加载和解析完成，才能正确渲染页面。
	- **解析与渲染的区别**：DOM解析是指构建DOM树的过程，而渲染是根据DOM和CSSOM来构建渲染树并显示内容的过程。解析是构建文档结构的步骤，而渲染是将这些结构可视化展示给用户的步骤。
* async和defer都是下载过程并行了，async执行过程还是可能阻塞，是乱序执行的，defer会等到dom都ready了，才执行
	* 

### 06 | 渲染流程（下）：HTML、CSS和JavaScript，是如何变成页面的？

* 在 DOM 生成、样式计算、布局计算后，绘制页面前，还需要
	* 复杂的 3D 转换、页面滚动、z-indexing 做 z 轴排序
	* 渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）
* 布局树和图层树关系示意图
	* 浏览器的页面实际上被分成了很多图层，这些图层叠加后合成了最终的页面。
	* 并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。
	* 那么需要满足什么条件，渲染引擎才会为特定的节点创建新的图层呢？通常满足下面两点中任意一点的元素就可以被提升为单独的一个图层。
		* 第一点，拥有层叠上下文属性的元素会被提升为单独的一层。
			* 明确定位属性的元素、定义透明属性的元素、使用 CSS 滤镜的元素等，都拥有层叠上下文属性。
		* 第二点，需要剪裁（clip）的地方也会被创建为图层。
			* div 的大小限定为 200 * 200 像素，而 div 里面的文字内容比较多，文字所显示的区域肯定会超出 200 * 200 的面积，这时候就产生了剪裁，渲染引擎会把裁剪文字内容的一部分用于显示在 div 区域，下图是运行时的执行结果：
* 图层绘制
	* 图层绘制阶段并不是真的绘制出图层，而是生成图层的绘制列表，然后将该绘制列表作为输入交由下一阶段
* 栅格化 raster 操作
	* 绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的合成线程来完成的。
	* 当图层的绘制列表准备好之后，主线程会把该绘制列表提交（commit）给合成线程
	* 屏幕上页面的可见区域就叫视口 （ViewPort）
	* 合成线程会将图层划分为图块（tile），这些图块的大小通常是 256x256 或者 512x512
	* 合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。
	* 而图块是栅格化执行的最小单位。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的
	* 通常，栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。
	* GPU 操作是运行在 GPU 进程中，如果栅格化操作使用了 GPU，那么最终生成位图的操作是在 GPU 中完成的，这就涉及到了跨进程操作
	* 渲染进程把生成图块的指令发送给 GPU，然后在 GPU 中执行生成图块的位图，并保存在 GPU 的内存中。
* 合成和显示
	* 一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。
	* 浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。
* 渲染流水线大总结
	* 整个渲染流程，从 HTML 到 DOM、样式计算、布局、图层、绘制、光栅化、合成和显示
	* 一个完整的渲染流程大致可总结为如下：
		* 渲染进程将 HTML 内容转换为能够读懂的 DOM 树结构。
		* 渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式。
		* 创建布局树，并计算元素的布局信息。
		* 对布局树进行分层，并生成分层树。
		* 为每个图层生成绘制列表，并将其提交到合成线程。
		* 合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。
		* 合成线程发送绘制图块命令 DrawQuad 给浏览器进程。
		* 浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。
* 相关概念
	* 1. 更新了元素的几何属性（重排）
		* 从上图可以看出，如果你通过 JavaScript 或者 CSS 修改元素的几何位置属性，例如改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫重排。无疑，重排需要更新完整的渲染流水线，所以开销也是最大的。
	* 2. 更新元素的绘制属性（重绘）
		* 如果修改了元素的背景颜色，那么布局阶段将不会被执行，因为并没有引起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程就叫重绘。相较于重排操作，重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些。
	* 3. 直接合成阶段
		* 如果你更改一个既不要布局也不要绘制的属性，会发生什么变化呢？渲染引擎将跳过布局和绘制，只执行后续的合成操作，我们把这个过程叫做合成。
* 评论区
	* 减少重排重绘, 方法很多： 
		1. 使用 class 操作样式，而不是频繁操作 style
		2. 避免使用 table 布局
		3. 批量 dom 操作，例如 createDocumentFragment，或者使用框架，例如 React
		4. Debounce window resize 事件
		5. 对 dom 属性的读写要分离
		6. will-change: transform 做优化

## 浏览器中的JavaScript执行机制（5讲）

### # 07 | 变量提升：JavaScript代码是按顺序执行的吗？

* 只有理解了 JavaScrip 的执行上下文，你才能更好地理解 JavaScript 语言本身，比如变量提升、作用域和闭包
* 所谓的变量提升，是指在 JavaScript 代码执行过程中，JavaScript 引擎把变量的声明部分和函数的声明部分提升到代码开头的“行为”。变量被提升后，会给变量设置默认值，这个默认值就是我们熟悉的 undefined。
* 实际上变量和函数声明在代码里的位置是不会改变的，而且是在编译阶段被 JavaScript 引擎放入内存中
* 一段 JavaScript 代码在执行之前需要被 JavaScript 引擎编译，编译完成之后，才会进入执行阶段。
* 输入一段代码，经过编译后，会生成两部分内容：执行上下文（Execution context）和可执行代码。
	* 执行上下文是 JavaScript 执行一段代码时的运行环境，比如调用一个函数，就会进入这个函数的执行上下文，确定该函数在执行期间用到的诸如 this、变量、对象以及函数等。
	* JavaScript 引擎发现了一个通过 function 定义的函数，所以它将函数定义存储到堆 (HEAP）中，并在环境对象中创建一个 showName 的属性，然后将该属性值指向堆中函数的位置
* JavaScript 引擎会把声明以外的代码编译为字节码
* JavaScript 的执行机制：先编译，再执行。
* 问答
	* 在同一个执行上下文中，函数声明的提升比比函数定义的优先级要更高

### 08 | 调用栈：为什么JavaScript代码会出现栈溢出？

三种情况：

* 当 JavaScript 执行全局代码的时候，会编译全局代码并创建全局执行上下文，而且在整个页面的生存周期内，全局执行上下文只有一份。
* 当调用一个函数的时候，函数体内的代码会被编译，并创建函数执行上下文，一般情况下，函数执行结束之后，创建的函数执行上下文会被销毁。
* 当使用 eval 函数的时候，eval 的代码也会被编译，并创建执行上下文。
* 调用栈是 JavaScript 引擎追踪函数执行的一个机制，当一次有多个函数被调用时，通过调用栈就能够追踪到哪个函数正在被执行以及各函数之间的调用关系。

## 09 | 块级作用域：var缺陷以及为什么要引入let和const？

* 正是由于 JavaScript 存在变量提升这种特性，从而导致了很多与直觉不符的代码，这也是 JavaScript 的一个重要设计缺陷。
* 通过块级作用域并配合 let 和 const 关键字来修复这种缺陷。
* 作用域是指在程序中定义变量的区域，该位置决定了变量的生命周期。通俗地理解，作用域就是变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期。
* 在 ES6 之前，ES 的作用域只有两种：全局作用域和函数作用域。
	* 全局作用域中的对象在代码中的任何地方都能访问，其生命周期伴随着页面的生命周期。
	* 函数作用域就是在函数内部定义的变量或者函数，并且定义的变量或者函数只能在函数内部被访问。函数执行结束之后，函数内部定义的变量会被销毁。
	* **闭包除外**，因为闭包里的变量还会被引用，所以不会和函数内部的其他变量一起被销毁。

```
JS引擎执行代码: (词法分析+语法解析+代码优化+代码生成)
* 1.1 编译 (编译结果放内存, 全局代码+函数体代码+eval内代码, 都会编译)
	* 1.1.1 执行上下文
		* 1.1.1.1 变量环境 ( var 和 function 声明的, 变量提升, 先变量后函数, 同名覆盖 , 全局作用于+函数作用域)
		* 1.1.1.2 词法环境 ( let 和 const 声明的, 有暂时性死区, 块级作用域, 从栈顶找到栈底 )
		* 1.1.1.3 outer => 指向全局执行上下文
		* 1.1.1.4 this => 为了实现对象打印自己的属性值, 因为作用域链不能满足这个需求 - 普通函数指向window(严格模式为undefined) - 嵌套函数不会继承父函数的this, 可用箭头函数, 箭头函数没有自己的this.继承父函数的this - 对象中的函数属性指向对象 - 构造函数中的this指向new的实例对象 - 可用bind/call/apply显示改变this指向
	* 1.1.2 可执行代码 (字节码)
* 1.2 执行 (遇到函数执行, eval执行, 会有重复多次编译执行, 执行上下文放在调用栈中, 需防止栈溢出(尾递归调用)+内存泄漏(释放变量为null))
	* 1.2.1 调用栈 (管理函数调用关系) - 在浏览器开发工具 : source => 打个断点 => 右侧调用栈中查看 - 调用栈有指定分配的深度, 递归容易栈溢出 ( 尾调用递归 + 加个定时器等) - 执行代码的变量查找机制: 作用域链 => 词法环境(静态的, 定义的时候就决定了) - 作用域：本地=>闭包(调用栈已弹出, 但是变量还保存在内存中,闭包变量避免用全局变量, 用局部变量, 垃圾回收机制会判断是否回收, 避免内存泄漏)=>全局
```


* 块级作用域
	* 相较而言，**其他语言则都普遍支持块级作用域**
	* 如果一种语言支持块级作用域，那么其代码块内部定义的变量在代码块外部是访问不到的，并且等该代码块中的代码执行完成之后，代码块中定义的变量会被销毁
	* 设计之初为了快速便捷，没有了块级作用域，再把作用域内部的变量统一提升无疑是最快速、最简单的设计
* let 可以先声明，之后再赋值。const 必须在声明的同时进行赋值
* 块级作用域就是通过词法环境的栈结构来实现的，而变量提升是通过变量环境来实现，通过这两者的结合，JavaScript 引擎也就同时支持了变量提升和块级作用域了。

这里涉及到一个临时性死区（TDZ）的知识：
变量在上下文的存在过程分3个阶段：创建、初始化、赋值；
* 创建：会在环境上下文创建一个该名字的变量，并为其分配内存空间； 
* 初始化：将该变量初始化为undefined； 
* 赋值：为该变量赋值；
* 其中，在编译时，会完成创建与初始化，也就是压栈操作； 但是let/const声明的变量只会在环境中创建该变量，并不会进行后面的初始化，在这创建与初始化中间这段时间是无法读取变量的。 
* 这段“时间”叫做临时性死区

* var的创建和初始化被提升，赋值不会被提升。
* let的创建被提升，初始化和赋值不会被提升。
* function的创建、初始化和赋值均会被提升。

* 函数只会在第一次执行的时候被编译，所以编译时变量环境和词法环境最顶层数据已经确定了。
* 在ES3开始，try /catch 分句结构中也具有块作用域

## 10|作用域链和闭包：代码中出现相同的变量，JavaScript引擎是如何选择的？

## 11| this：从JavaScript执行上下文的视角讲清楚this


