
## 2024-01-08

* 表单场景一直都是前端中后台领域最复杂的场景，复杂度：
	* 字段数量多
	* 字段关联逻辑复杂
	* 表单数据管理复杂
	* 表单状态管理复杂
	* 表单的场景化复用
	* 动态渲染诉求很强烈
* 表单联动，用 setState 心智成本低，但性能问题大
	* 每次输入都会导致所有字段全量渲染
	* 虽然在 DOM 更新层面是有 diff，但是 diff 也是有计算成本的，浪费了很多计算资源
	* 初次渲染表单是 O(n)，字段输入时也是 O(n)
* MVVM 设计模式 -> Mobx
	* 几十年前，人类创造出了 MVVM 设计模式。这样的设计模式核心是将视图模型抽象出来，然后在 DSL 模板层消费，DSL 借助某种依赖收集机制，然后在视图模型中统一调度，保证每次输入都是精确渲染的，这就是工业级的 GUI 形态！
	* github 社区为这样的 MVVM 模型抽象出了一个叫 [Mobx](https://github.com/mobxjs/mobx) 的状态管理解决方案，Mobx 最核心的能力就是它的依赖追踪机制和响应式模型的抽象能力。
	* 借助 Mobx，完全可以解决表单字段输入过程中的 O(n)问题
* Mobx -> formily
	* Formily2.x 在实现的过程中发现 Mobx 还是存在一些不兼容 Formily 核心思想的问题，最终，只能重新造了一个轮子，延续 Mobx 的核心思想的 [@formily/reactive](https://reactive.formilyjs.org/zh-CN)
	* react-hook-form 号称业界性能第一的表单方案，值管理做到了精确渲染
		* 缺点：触发校验的时候，还是会导致表单全量渲染
		* 缺点：react-hook-form 要实现联动，同样是需要整体受控渲染才能实现联动
* 领域模型
	* 大多数表单联动，基本上都是**基于某些字段的值引发的联动**，但是实际还会**基于其他副作用值引发联动**，比如应用状态，服务端数据状态，页面 URL，某个字段 UI 组件内部数据，当前字段自身的其他数据状态，某些特殊异步事件等等。
	* 核心是将字段的某些状态属性与某些数据关联起来
	*  component 属性，它代表了字段所对应的 UI 组件和 UI 组件属性
	* 领域模型，让表单的联动变得可枚举可预测，为后面的协议描述联动打下了坚实基础。
* 路径系统
	* 不止是字段模型，必须还要有一个表单模型作为顶层模型，顶层模型管理着所有字段模型，每个字段都有着自己的路径
	* Formily 独创的路径系统 @formily/path 很好的解决了这个问题，不仅仅是让字段查找变得优雅，它还能通过解构表达式去处理前后端数据结构不一致的恶心问题。
* 生命周期
	* 借助 Mobx 和路径系统，已经比较完备的表单方案，但外界无法感知内部流转过程，想要在某个过程阶段内实现一些逻辑则无法实现
	* 因此需要生命周期，只要将整个表单生命周期作为事件钩子暴露给外界，这样就能做到了既有抽象，但又灵活的表单方案。
* 协议驱动
	* 要实现动态可配置表单，要将表单结构变得可序列化
		* 以 UI 为思路的 UI 描述协议
		* 以数据为思路的数据描述协议（表单本身就是为了维护一份数据，那自然而然，对于表单场景而言，数据协议最适合不过）
	* 想要描述数据结构，现在业界最流行的就是 [JSON-Schema](https://json-schema.org/) 了
		* JSON Schema 协议上本身就有很多校验相关的属性，这就天然和表单校验关联上
	* UI 描述协议与数据描述协议的对比
		* UI 描述协议适合更通用的 UI 表达，描述表单当然不在话下，只是它会更偏前端协议
		* 相反，JSON-Schema，在后端模型层，都是可表达的，在描述数据上更通用
		* 两种协议，各有所长，只是在单纯表单领域，JSON-Schema 会更偏领域化一些
	* react-jsonschema-form 和 formily 区别
		* [react-jsonschema-form](https://github.com/rjsf-team/react-jsonschema-form)：数据和 UI 分开。各个协议都是非常纯净的协议 -> 较大的维护成本和理解成本，用户要开发一个表单，需要不断的在两种协议心智上做切换
		* Formily 的表单协议会更加倾向于在 JSON-Schema 上做扩展。
			* x-* 来表达拓展属性
			* UI 协议与数据协议混合在一起，只要有一个统一的扩展约定，也还是能保证两种协议职责单一
	* 要在某些字段上包裹一个 UI 容器怎么办？
		* Formily 定义了一个新的 schema type，叫`void`
		* W3C 规范里也有 void element，js 里也有 void 关键字，前者代表虚元素，后者代表虚指针
		* 在 JSON Schema 中，引入 void，代表一个虚数据节点，表示该节点并不占用实际数据结构
	* 被动联动：`x-reactions`描述了 target 字段，依赖了 source 字段的值，如果值为`'123'`的时候则显示 target 字段，否则隐藏
	* 主动联动：只需要将`x-reactions`换个位置，放到 source 字段上，然后再指定一个 target 即可。

