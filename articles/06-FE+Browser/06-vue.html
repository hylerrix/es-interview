<!doctype html><html class="" data-reactroot=""><head><script async="" src="https://www.google-analytics.com/analytics.js"></script><script>
            window.GoogleAnalyticsObject="ga";(window.ga=window.ga||function(){(window.ga.q=window.ga.q||[]).push(arguments);}),(window.ga.l=1*new Date());

            ga('create', 'UA-169223577-1', 'auto');
            ga('send', 'pageview');</script><link rel="icon" type="image/png" href="/favicon.png"/>
<meta data-react-helmet="true" charset="utf-8"/><meta data-react-helmet="true" http-equiv="x-ua-compatible" content="ie=edge"/><meta data-react-helmet="true" name="description" content="收集汇总梳理全网资源，涵盖 JS/TS 前后端的全方位面试题库（含提示性解析），助力找个好工作！"/><meta data-react-helmet="true" name="viewport" content="width=device-width, initial-scale=1"/>
<title data-react-helmet="true">Vue · ECMAScript+ 面试宝典</title>
<link data-react-helmet="true" rel="stylesheet" href="/assets/index.css"/><link data-react-helmet="true" id="prismTheme" rel="stylesheet" href="/assets/prism.css"/><link data-react-helmet="true" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossOrigin="anonymous"/>
<script data-react-helmet="true" >
    const shouldSetIsDark = document.cookie.includes('is_dark=1') ? true : document.cookie.includes('is_dark=0') ? false : window.matchMedia('(prefers-color-scheme: dark)').matches;
    if (shouldSetIsDark) {
      document.documentElement.classList.add('is_dark');
      document.getElementById('prismTheme').href = "/assets/prism_tomorrow.css";
    }
  </script>
</head><body><header><h1 class="hide_on_mobile"><a href="/">ECMAScript+ 面试宝典</a></h1><nav><ul><li class="show_on_mobile flex_center"><a class="czs-menu-l" href="#" style="background-image:url(&quot;/assets/czs-menu-l.svg&quot;)"></a></li><li class="show_on_mobile"><h1 class="mobile_title"><a href="/">ECMAScript+ 面试宝典</a></h1></li><li class="hide_on_mobile"><a href="/articles/">文章</a></li><li class="hide_on_mobile"><a href="http://qiniu.ningo.cloud/hylerrix/reward-alipay.png" target="_blank">打赏一下!!</a></li><li class="hide_on_mobile"><a href="https://github.com/hylerrix/deno-tutorial" target="_blank">Deno 钻研之术</a></li><li class="hide_on_mobile"><a href="https://github.com/hylerrix" target="_blank">持续添加中...</a></li><li class="hide_on_mobile"><a href="https://github.com/ningowood" target="_blank">凝果屋</a></li><li class="hide_on_mobile"><a href="https://github.com/hylerrix" target="_blank">关于</a></li><li style="flex-grow:1"></li><li class="flex_center"><a class="czs-github-logo" href="https://github.com/hylerrix/es-interview" target="_blank" style="background-image:url(&quot;/assets/czs-github-logo.svg&quot;)"></a></li><li class="toggle_dark flex_center"><span class="czs-sun" style="background-image:url(&quot;/assets/czs-sun.svg&quot;)"></span><span class="czs-sun-l" style="background-image:url(&quot;/assets/czs-sun-l.svg&quot;)"></span><span class="czs-moon" style="background-image:url(&quot;/assets/czs-moon.svg&quot;)"></span><span class="czs-moon-l" style="background-image:url(&quot;/assets/czs-moon-l.svg&quot;)"></span></li></ul></nav></header><aside class="sidebar"><ol><li class=""><a href="/articles/index.html" class="nav_link">ESMAScript+ 面试宝典</a></li><li class=""><a href="/articles/es-timeline.html" class="nav_link">前端大事记</a></li><li class=""><a href="/articles/es-direction.html" class="nav_link">ES 方向 &amp; 谁在招人？</a></li><li class=""><a href="/articles/00-Profession/index.html" class="nav_link">职业 &amp; 成长</a></li><li class="unfold"><a href="/articles/01-Programming/index.html" class="nav_link">编程基础<span class="czs-angle-up-l" style="background-image:url(&quot;/assets/czs-angle-up-l.svg&quot;)"></span><span class="czs-angle-down-l" style="background-image:url(&quot;/assets/czs-angle-down-l.svg&quot;)"></span></a><ol><li class=""><a href="/articles/01-Programming/00-language.html" class="nav_link">编程语言</a></li><li class=""><a href="/articles/01-Programming/01-operating-system.html" class="nav_link">操作系统</a></li><li class=""><a href="/articles/01-Programming/02-algorithms.html" class="nav_link">算法</a></li><li class=""><a href="/articles/01-Programming/03-design-patterns.html" class="nav_link">设计模式</a></li><li class=""><a href="/articles/01-Programming/04-software-engineering.html" class="nav_link">软件工程</a></li><li class=""><a href="/articles/01-Programming/05-software-test.html" class="nav_link">测试</a></li><li class=""><a href="/articles/01-Programming/06-version-control.html" class="nav_link">版本控制</a></li><li class=""><a href="/articles/01-Programming/07-computer-principles.html" class="nav_link">计算机组成原理</a></li><li class=""><a href="/articles/01-Programming/08-compilation-principle.html" class="nav_link">编译原理</a></li></ol></li><li class="unfold"><a href="/articles/02-ECMAScript+/index.html" class="nav_link">ECMAScript+<span class="czs-angle-up-l" style="background-image:url(&quot;/assets/czs-angle-up-l.svg&quot;)"></span><span class="czs-angle-down-l" style="background-image:url(&quot;/assets/czs-angle-down-l.svg&quot;)"></span></a><ol><li class=""><a href="/articles/02-ECMAScript+/00-ecmascript.html" class="nav_link">ECMAScript</a></li><li class=""><a href="/articles/02-ECMAScript+/01-javascript.html" class="nav_link">JavaScript 基础知识</a></li><li class=""><a href="/articles/02-ECMAScript+/02-typescript.html" class="nav_link">TypeScript</a></li><li class=""><a href="/articles/02-ECMAScript+/03-javascript-parctice.html" class="nav_link">JavaScript 常见实战题</a></li></ol></li><li class="unfold"><a href="/articles/03-HTML+CSS/index.html" class="nav_link">HTML + CSS<span class="czs-angle-up-l" style="background-image:url(&quot;/assets/czs-angle-up-l.svg&quot;)"></span><span class="czs-angle-down-l" style="background-image:url(&quot;/assets/czs-angle-down-l.svg&quot;)"></span></a><ol><li class=""><a href="/articles/03-HTML+CSS/00-html.html" class="nav_link">HTML</a></li><li class=""><a href="/articles/03-HTML+CSS/01-css-design.html" class="nav_link">CSS</a></li><li class=""><a href="/articles/03-HTML+CSS/02-html-css-practice.html" class="nav_link">HTML + CSS 实战</a></li><li class=""><a href="/articles/03-HTML+CSS/03-dom-bom.html" class="nav_link">DOM + BOM</a></li></ol></li><li class="unfold"><a href="/articles/04-Network+API/index.html" class="nav_link">网络 + 前后端协作<span class="czs-angle-up-l" style="background-image:url(&quot;/assets/czs-angle-up-l.svg&quot;)"></span><span class="czs-angle-down-l" style="background-image:url(&quot;/assets/czs-angle-down-l.svg&quot;)"></span></a><ol><li class=""><a href="/articles/04-Network+API/00-network.html" class="nav_link">网络</a></li><li class=""><a href="/articles/04-Network+API/01-fe-be-api.html" class="nav_link">前后端协作</a></li><li class=""><a href="/articles/04-Network+API/02-network-security.html" class="nav_link">网络安全</a></li></ol></li><li class="unfold"><a href="/articles/05-V8+Runtime/index.html" class="nav_link">V8 + JavaScript 运行时<span class="czs-angle-up-l" style="background-image:url(&quot;/assets/czs-angle-up-l.svg&quot;)"></span><span class="czs-angle-down-l" style="background-image:url(&quot;/assets/czs-angle-down-l.svg&quot;)"></span></a><ol><li class=""><a href="/articles/05-V8+Runtime/00-v8.html" class="nav_link">V8</a></li><li class=""><a href="/articles/05-V8+Runtime/01-node.html" class="nav_link">Node</a></li><li class=""><a href="/articles/05-V8+Runtime/02-deno.html" class="nav_link">Deno</a></li></ol></li><li class="unfold"><a href="/articles/06-FE+Browser/index.html" class="nav_link">前端应用开发 + 浏览器<span class="czs-angle-up-l" style="background-image:url(&quot;/assets/czs-angle-up-l.svg&quot;)"></span><span class="czs-angle-down-l" style="background-image:url(&quot;/assets/czs-angle-down-l.svg&quot;)"></span></a><ol><li class=""><a href="/articles/06-FE+Browser/00-browser.html" class="nav_link">浏览器</a></li><li class=""><a href="/articles/06-FE+Browser/01-fe-engineering.html" class="nav_link">前端工程化</a></li><li class=""><a href="/articles/06-FE+Browser/02-fe-tooltain.html" class="nav_link">前端工具链</a></li><li class=""><a href="/articles/06-FE+Browser/03-pack-tool.html" class="nav_link">前端打包工具</a></li><li class=""><a href="/articles/06-FE+Browser/04-fe-mobile.html" class="nav_link">移动端 Web 开发</a></li><li class=""><a href="/articles/06-FE+Browser/05-react.html" class="nav_link">React</a></li><li class=""><a href="/articles/06-FE+Browser/06-vue.html" class="nav_link active">Vue</a></li><li class=""><a href="/articles/06-FE+Browser/07-iframe.html" class="nav_link">iframe</a></li></ol></li><li class="unfold"><a href="/articles/07-BE+Server/index.html" class="nav_link">后端应用开发 + 服务器<span class="czs-angle-up-l" style="background-image:url(&quot;/assets/czs-angle-up-l.svg&quot;)"></span><span class="czs-angle-down-l" style="background-image:url(&quot;/assets/czs-angle-down-l.svg&quot;)"></span></a><ol><li class=""><a href="/articles/07-BE+Server/00-linux-nginx-database.html" class="nav_link">Linux + Nginx + 数据库</a></li><li class=""><a href="/articles/07-BE+Server/01-node-framework.html" class="nav_link">Node 框架</a></li></ol></li><li class=""><a href="/articles/draw-in-markdown.html" class="nav_link">如何用 Markdown 绘制图片</a></li><li class=""><a href="/articles/roadmap.html" class="nav_link">变更日志</a></li></ol></aside><section class="main"><div class="main_article"><article><h1>Vue</h1>
<blockquote>
<p><a href="https://juejin.im/post/6844903876231954446">vue 269 个知识点（面试题）为你保驾护航</a>。</p>
</blockquote>
<h2 id="react-%E5%92%8C-vue-%E7%9A%84%E5%8C%BA%E5%88%AB">React 和 Vue 的区别？<a class="anchor" href="#react-%E5%92%8C-vue-%E7%9A%84%E5%8C%BA%E5%88%AB">§</a></h2>
<p>相同点</p>
<ul>
<li>都有组件化开发和Virtual DOM</li>
<li>都支持props进行父子组件间数据通信</li>
<li>都支持数据驱动视图, 不直接操作真实DOM, 更新状态数据界面就自动更新</li>
<li>都支持服务器端渲染</li>
<li>都有支持native的方案,React的React Native,Vue的Weex</li>
</ul>
<p>不同点</p>
<ul>
<li>数据绑定: vue实现了数据的双向绑定,react数据流动是单向的</li>
<li>组件写法不一样, React推荐的做法是 JSX , 也就是把HTML和CSS全都写进JavaScript了,即'all in js'; Vue推荐的做法是webpack+vue-loader的单文件组件格式,即html,css,js写在同一个文件</li>
<li>state对象在react应用中不可变的,需要使用setState方法更新状态;在vue中,state对象不是必须的,数据由data属性在vue对象中管理</li>
<li>virtual DOM不一样,vue会跟踪每一个组件的依赖关系,不需要重新渲染整个组件树.而对于React而言,每当应用的状态被改变时,全部组件都会重新渲染,所以react中会需要shouldComponentUpdate这个生命周期函数方法来进行控制</li>
<li>React严格上只针对MVC的view层,Vue则是MVVM模式</li>
</ul>
<p>概念</p>
<ul>
<li>
<p>组件通信：父向子、子向父、隔代、兄弟</p>
</li>
<li>
<p>实现通信方式</p>
</li>
<li>
<ul>
<li>props：父向子传递一般属性、子向父传递函数属性；缺点隔代不好</li>
<li>vue 自定义事件：Vue 内置，代替函数类型的 props【绑定监听 @、触发事件 emit】</li>
<li>消息订阅与发布：常见订阅库 pubsub-js，适用于任意关系组件</li>
<li>vuex：相比 pubsub 管理起来更集中方便</li>
<li>slot：专门用来实现父向子传递带数据的标签</li>
</ul>
</li>
</ul>
<h2 id="vue-13-%E7%9A%84%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7">Vue 1~3 的版本特性<a class="anchor" href="#vue-13-%E7%9A%84%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7">§</a></h2>
<blockquote>
<p><a href="https://cn.vuejs.org/v2/guide/migration.html">从 Vue 1.x 迁移到 V2</a></p>
</blockquote>
<ul>
<li>
<p>Vue1：</p>
<ul>
<li>生命周期：<code>init; created; beforeCompile; compiled; ready; beforeDestroy; destroyed; </code>。</li>
<li>提高循环性能需添加 <code>track-by='$index'</code></li>
<li><code>v-for=&quot;(index,val) in array&quot;</code></li>
<li>transition 只是一个属性</li>
<li><code>&lt;a v-link=&quot;{path:'/home'}&quot;&gt;我是主页&lt;/a&gt;</code></li>
</ul>
</li>
<li>
<p>Vue 2：</p>
<ul>
<li>生命周期：
<ul>
<li><code>beforeCreate; created; beforeMount; mounted; beforeUpdate; updated; beforeDestroy; destroyed;</code>。</li>
<li>移除：<code>beforeCompile; attached; detached; </code></li>
<li>替换：<code>compiled, ready -&gt; mounted</code></li>
<li>重新命名：<code>init -&gt; beforeCreate</code></li>
</ul>
</li>
<li>Virtual-DOM
<ul>
<li>渲染层开始基于轻量级的 Virtual DOM 实现，大多数情况下初始化渲染速度和内存消耗都提升了 2~4 倍</li>
<li>从模板到 Virtual DOM 的编译阶段使用了一些高阶优化：
<ul>
<li>它会检测出静态的 class 名和 attributes 这样它们在初始化渲染之后就永远都不会再被比对。</li>
<li>它会检测出最大静态子树 (就是不需要动态性的子树) 并且从渲染函数中萃取出来。这样在每次重渲染的时候，它就会直接重用完全相同的 virtual nodes 同时跳过比对。</li>
</ul>
</li>
<li>新的渲染系统同时允许你通过简单的冻结数据来禁用响应式转换，配以手动的强制更新，这意味着你对于重渲染的流程实际上有着完全的控制权。</li>
</ul>
</li>
<li>可选支持 JSX</li>
<li>支持服务端渲染，相比同时期的同步 SSR React，Vue 2 提供了内建的流式 SSR：在渲染组件时返回一个可读的 stream，然后直接 pipe 到 HTTP response。流式渲染能够确保服务端的响应度，也能让用户更快地获得渲染内容。</li>
<li>不支持片段代码，<code>template</code> 下只接受一个根节点。</li>
<li>提高循环性能可不添加 <code>:key=&quot;index&quot;</code></li>
<li>transition 是一个组件</li>
<li><code>&lt;router-link to=&quot;/home&quot;&gt;我是主页&lt;/router-link&gt;</code></li>
</ul>
</li>
</ul>
<h2 id="vue-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">Vue 的生命周期<a class="anchor" href="#vue-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">§</a></h2>
<ul>
<li>beforeCreate：组件实例被创建之初，组件的属性生效之前</li>
<li>created：组件实例已经完全创建，属性也绑定，但真实dom还没有生成， $el 还不可用</li>
<li>beforeMount：在挂载开始之前被调用:相关的 render 函数首次被调用</li>
<li>mounted el：被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子</li>
<li>beforeUpdate：组件数据更新之前调用，发生在虚拟 DOM 打补丁之前</li>
<li>update：组件数据更新之后</li>
<li>activited：keep-alive专属，组件被激活时调用</li>
<li>deadctivated：keep-alive专属，组件被销毁时调用</li>
<li>beforeDestory：组件销毁前调用</li>
<li>destoryed：组件销毁后调用</li>
</ul>
<h2 id="%E5%AE%9E%E7%8E%B0-vue-%E7%9A%84%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A">实现 Vue 的双向绑定<a class="anchor" href="#%E5%AE%9E%E7%8E%B0-vue-%E7%9A%84%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A">§</a></h2>
<p>Vue 2.x 的 Object.defineProperty 版本</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token comment">// 数据</span>
<span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token punctuation">{</span>
  text<span class="token operator">:</span> <span class="token string">'default'</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> input <span class="token operator">=</span> <span class="token dom variable">document</span><span class="token punctuation">.</span><span class="token method function property-access">getElementById</span><span class="token punctuation">(</span><span class="token string">'input'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> span <span class="token operator">=</span> <span class="token dom variable">document</span><span class="token punctuation">.</span><span class="token method function property-access">getElementById</span><span class="token punctuation">(</span><span class="token string">'span'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 数据劫持</span>
<span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">defineProperty</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token string">'text'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token comment">// 数据变化 —> 修改视图</span>
  <span class="token function">set</span><span class="token punctuation">(</span>newVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    input<span class="token punctuation">.</span><span class="token property-access">value</span> <span class="token operator">=</span> newVal<span class="token punctuation">;</span>
    span<span class="token punctuation">.</span><span class="token property-access">innerHTML</span> <span class="token operator">=</span> newVal<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 视图更改 --> 数据变化</span>
input<span class="token punctuation">.</span><span class="token method function property-access">addEventListener</span><span class="token punctuation">(</span><span class="token string">'keyup'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  data<span class="token punctuation">.</span><span class="token property-access">text</span> <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token property-access">target</span><span class="token punctuation">.</span><span class="token property-access">value</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>Vue 3.x 的 proxy 版本</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token comment">// 数据</span>
<span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token punctuation">{</span>
  text<span class="token operator">:</span> <span class="token string">'default'</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> input <span class="token operator">=</span> <span class="token dom variable">document</span><span class="token punctuation">.</span><span class="token method function property-access">getElementById</span><span class="token punctuation">(</span><span class="token string">'input'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> span <span class="token operator">=</span> <span class="token dom variable">document</span><span class="token punctuation">.</span><span class="token method function property-access">getElementById</span><span class="token punctuation">(</span><span class="token string">'span'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 数据劫持</span>
<span class="token keyword">const</span> handler <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    target<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>
    <span class="token comment">// 数据变化 —> 修改视图</span>
    input<span class="token punctuation">.</span><span class="token property-access">value</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>
    span<span class="token punctuation">.</span><span class="token property-access">innerHTML</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>
    <span class="token keyword control-flow">return</span> value<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 视图更改 --> 数据变化</span>
input<span class="token punctuation">.</span><span class="token method function property-access">addEventListener</span><span class="token punctuation">(</span><span class="token string">'keyup'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  proxy<span class="token punctuation">.</span><span class="token property-access">text</span> <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token property-access">target</span><span class="token punctuation">.</span><span class="token property-access">value</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<h2 id="vue-%E7%BB%84%E4%BB%B6%E5%A6%82%E4%BD%95%E9%80%9A%E4%BF%A1">Vue 组件如何通信？<a class="anchor" href="#vue-%E7%BB%84%E4%BB%B6%E5%A6%82%E4%BD%95%E9%80%9A%E4%BF%A1">§</a></h2>
<ul>
<li>props/<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mi>m</mi><mi>i</mi><mi>t</mi><mo>+</mo><mi>v</mi><mo>−</mo><mi>o</mi><mi>n</mi><mo>:</mo><mtext>通过</mtext><mi>p</mi><mi>r</mi><mi>o</mi><mi>p</mi><mi>s</mi><mtext>将数据自上而下传递，而通过</mtext></mrow><annotation encoding="application/x-tex">emit+v-on: 通过props将数据自上而下传递，而通过</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord cjk_fallback">通</span><span class="mord cjk_fallback">过</span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">o</span><span class="mord mathnormal">p</span><span class="mord mathnormal">s</span><span class="mord cjk_fallback">将</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">据</span><span class="mord cjk_fallback">自</span><span class="mord cjk_fallback">上</span><span class="mord cjk_fallback">而</span><span class="mord cjk_fallback">下</span><span class="mord cjk_fallback">传</span><span class="mord cjk_fallback">递</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">而</span><span class="mord cjk_fallback">通</span><span class="mord cjk_fallback">过</span></span></span></span>emit和v-on来向上传递信息。</li>
<li>EventBus: 通过EventBus进行信息的发布与订阅</li>
<li>vuex: 是全局数据管理库，可以通过vuex管理全局的数据流</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>t</mi><mi>t</mi><mi>r</mi><mi>s</mi><mi mathvariant="normal">/</mi></mrow><annotation encoding="application/x-tex">attrs/</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">s</span><span class="mord">/</span></span></span></span>listeners: Vue2.4中加入的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>t</mi><mi>t</mi><mi>r</mi><mi>s</mi><mi mathvariant="normal">/</mi></mrow><annotation encoding="application/x-tex">attrs/</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">s</span><span class="mord">/</span></span></span></span>listeners可以进行跨级的组件通信</li>
<li>provide/inject:以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成 立的时间里始终生效，这成为了跨组件通信的基础</li>
<li>还有用 solt 插槽或 ref 实例进行通信</li>
</ul>
<h2 id="computed-%E5%92%8C-watch-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">computed 和 Watch 有什么区别？<a class="anchor" href="#computed-%E5%92%8C-watch-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">§</a></h2>
<ul>
<li>computed：
<ul>
<li>computed 是计算属性，也就是计算值，它更多用于计算值的场景。</li>
<li>computed 具有缓存性，computed 的值在 getter 执行后会缓存，只有在它依赖的属性值改变之后，下一次获取 computed 的值才会重新调用对应的 getter 来计算。</li>
<li>computed 适用于计算比较消耗性能的计算场景。</li>
</ul>
</li>
<li>watch：
<ul>
<li>更多的是观察的作用，监听回调。</li>
<li>无缓存性，页面重新渲染时值不变化也会执行</li>
</ul>
</li>
<li>当我们进行数值计算，而且依赖于其它数据时，用 computed</li>
<li>如果需要在某个数据变化时做一些事情，使用 watch 来观察这个数据的变化。</li>
</ul>
<h2 id="vue-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A">Vue 如何实现双向绑定？<a class="anchor" href="#vue-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A">§</a></h2>
<ul>
<li>利用 Object.defineProperty 劫持对象的访问器，在属性值发生变化时获取变化后响应。</li>
<li>Vue 3 中通过 Proxy 代理对象进行类似的操作。</li>
</ul>
<h2 id="%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3-vue-%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F">如何理解 Vue 响应式系统？<a class="anchor" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3-vue-%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F">§</a></h2>
<ul>
<li>任何一个 Vue Component 都有一个与之对应的 Watcher 实例。</li>
<li>Vue 的 data 上的属性会被添加 getter 和 setter 属性。</li>
<li>当 Vue Component render 函数被执行的时候，data 上会被触碰（被读），getter 会被调用，此时 Vue 会记录此 Vue Component 所依赖的所有 data。（依赖收集）</li>
<li>data 被改动时，setter 会被调用，此时 Vue 会去通知所有依赖此 data 的组件去调用他们的 render 函数进行更新。</li>
</ul>
<h2 id="%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3-vue-%E7%9A%84%E4%BE%9D%E8%B5%96%E6%94%B6%E9%9B%86">如何理解 Vue 的依赖收集？<a class="anchor" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3-vue-%E7%9A%84%E4%BE%9D%E8%B5%96%E6%94%B6%E9%9B%86">§</a></h2>
<h2 id="%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3-vue-%E7%9A%84%E5%8F%98%E5%8C%96%E4%BE%A6%E6%B5%8B%E5%8E%9F%E7%90%86">如何理解 Vue 的变化侦测原理？<a class="anchor" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3-vue-%E7%9A%84%E5%8F%98%E5%8C%96%E4%BE%A6%E6%B5%8B%E5%8E%9F%E7%90%86">§</a></h2>
<ul>
<li>Vue 已经可以数据劫持后，为什么还需要虚拟 DOM 进行 diff 检测差异？
<ul>
<li>现代前端框架有两种方式侦测变化,一种是pull一种是push</li>
<li>pull: 其代表为React,我们可以回忆一下React是如何侦测到变化的,我们通常会用 setState API显式更新,然后React会进 行一层层的Virtual Dom Diff操作找出差异,然后Patch到DOM上,React从一开始就不知道到底是哪发生了变化,只是知道 「有变化了」,然后再进行比较暴力的Diff操作查找「哪发生变化了」，另外一个代表就是Angular的脏检查操作。</li>
<li>push: Vue的响应式系统则是push的代表,当Vue程序初始化的时候就会对数据data进行依赖的收集,一但数据发生变化,响 应式系统就会立刻得知,因此Vue是一开始就知道是「在哪发生变化了」,但是这又会产生一个问题,如果你熟悉Vue的响 应式系统就知道,通常一个绑定一个数据就需要一个Watcher,一但我们的绑定细粒度过高就会产生大量的Watcher,这会 带来内存以及依赖追踪的开销,而细粒度过低会无法精准侦测变化,因此Vue的设计是选择中等细粒度的方案,在组件级别 进行push侦测的方式,也就是那套响应式系统,通常我们会第一时间侦测到发生变化的组件,然后在组件内部进行Virtual Dom Diff获取更加具体的差异,而Virtual Dom Diff则是pull操作,Vue是push+pull结合的方式进行变化侦测的。</li>
</ul>
</li>
<li>Vue 中为什么没有类似的 shouldComponentUpdate？
<ul>
<li>React是pull的方式侦测变化,当React知道发生变化后,会使用Virtual Dom Diff进行差异检测,但是很多组件实际上是肯定 不会发生变化的,这个时候需要用shouldComponentUpdate进行手动操作来减少diff,从而提高程序整体的性能.</li>
<li>Vue是pull+push的方式侦测变化的,在一开始就知道那个组件发生了变化,因此在push的阶段并不需要手动控制diff,而组 件内部采用的diff方式实际上是可以引入类似于shouldComponentUpdate相关生命周期的,但是通常合理大小的组件不会 有过量的diff,手动优化的价值有限,因此目前Vue并没有考虑引入shouldComponentUpdate这种手动优化的生命周期.</li>
</ul>
</li>
</ul>
<h2 id="%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3-vue-%E7%9A%84-keep-alive">如何理解 Vue 的 Keep-Alive？<a class="anchor" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3-vue-%E7%9A%84-keep-alive">§</a></h2>
<h2 id="%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3-gettersetter-%E4%B8%8D%E8%83%BD%E7%9B%91%E5%90%AC%E6%95%B0%E7%BB%84%E5%8F%98%E5%BC%82%E6%96%B9%E6%B3%95">如何解决 getter/setter 不能监听数组变异方法<a class="anchor" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3-gettersetter-%E4%B8%8D%E8%83%BD%E7%9B%91%E5%90%AC%E6%95%B0%E7%BB%84%E5%8F%98%E5%BC%82%E6%96%B9%E6%B3%95">§</a></h2>
<h2 id="%E7%9B%91%E5%90%AC%E7%9A%84%E5%9B%9E%E8%B0%83%E5%92%8C%E4%BA%8B%E4%BB%B6%E6%80%8E%E4%B9%88%E8%A7%A3%E8%80%A6%E7%9A%84">监听的回调和事件怎么解耦的<a class="anchor" href="#%E7%9B%91%E5%90%AC%E7%9A%84%E5%9B%9E%E8%B0%83%E5%92%8C%E4%BA%8B%E4%BB%B6%E6%80%8E%E4%B9%88%E8%A7%A3%E8%80%A6%E7%9A%84">§</a></h2>
<h2 id="watcher-%E5%8E%BB%E9%87%8D%E6%80%8E%E4%B9%88%E5%81%9A%E7%9A%84">watcher 去重怎么做的<a class="anchor" href="#watcher-%E5%8E%BB%E9%87%8D%E6%80%8E%E4%B9%88%E5%81%9A%E7%9A%84">§</a></h2>
<h2 id="dom%E6%89%B9%E6%9B%B4%E6%96%B0%E6%80%8E%E4%B9%88%E5%81%9A%E7%9A%84">DOM批更新怎么做的<a class="anchor" href="#dom%E6%89%B9%E6%9B%B4%E6%96%B0%E6%80%8E%E4%B9%88%E5%81%9A%E7%9A%84">§</a></h2></article><div class="prev_next"><a class="prev button" href="/articles/06-FE+Browser/05-react.html">«  <!-- -->React</a><a class="next button" href="/articles/06-FE+Browser/07-iframe.html">iframe<!-- -->  »</a></div></div><div class="main_toc_container nav_link_container"><div class="main_toc"><aside><nav class="toc"><ol><li><a href="#react-%E5%92%8C-vue-%E7%9A%84%E5%8C%BA%E5%88%AB">React 和 Vue 的区别？</a></li><li><a href="#vue-13-%E7%9A%84%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7">Vue 1~3 的版本特性</a></li><li><a href="#vue-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">Vue 的生命周期</a></li><li><a href="#%E5%AE%9E%E7%8E%B0-vue-%E7%9A%84%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A">实现 Vue 的双向绑定</a></li><li><a href="#vue-%E7%BB%84%E4%BB%B6%E5%A6%82%E4%BD%95%E9%80%9A%E4%BF%A1">Vue 组件如何通信？</a></li><li><a href="#computed-%E5%92%8C-watch-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">computed 和 Watch 有什么区别？</a></li><li><a href="#vue-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A">Vue 如何实现双向绑定？</a></li><li><a href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3-vue-%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F">如何理解 Vue 响应式系统？</a></li><li><a href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3-vue-%E7%9A%84%E4%BE%9D%E8%B5%96%E6%94%B6%E9%9B%86">如何理解 Vue 的依赖收集？</a></li><li><a href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3-vue-%E7%9A%84%E5%8F%98%E5%8C%96%E4%BE%A6%E6%B5%8B%E5%8E%9F%E7%90%86">如何理解 Vue 的变化侦测原理？</a></li><li><a href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3-vue-%E7%9A%84-keep-alive">如何理解 Vue 的 Keep-Alive？</a></li><li><a href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3-gettersetter-%E4%B8%8D%E8%83%BD%E7%9B%91%E5%90%AC%E6%95%B0%E7%BB%84%E5%8F%98%E5%BC%82%E6%96%B9%E6%B3%95">如何解决 getter/setter 不能监听数组变异方法</a></li><li><a href="#%E7%9B%91%E5%90%AC%E7%9A%84%E5%9B%9E%E8%B0%83%E5%92%8C%E4%BA%8B%E4%BB%B6%E6%80%8E%E4%B9%88%E8%A7%A3%E8%80%A6%E7%9A%84">监听的回调和事件怎么解耦的</a></li><li><a href="#watcher-%E5%8E%BB%E9%87%8D%E6%80%8E%E4%B9%88%E5%81%9A%E7%9A%84">watcher 去重怎么做的</a></li><li><a href="#dom%E6%89%B9%E6%9B%B4%E6%96%B0%E6%80%8E%E4%B9%88%E5%81%9A%E7%9A%84">DOM批更新怎么做的</a></li></ol></nav></aside></div></div></section><footer>Powered by<!-- --> <a href="https://github.com/xcatliu/pagic" target="_blank">Pagic</a></footer><div class="tools flex_center hide_on_mobile"><a class="czs-pen button" href="https://github.com/hylerrix/es-interview/edit/master/articles/06-FE+Browser/06-vue.md" target="_blank" style="background-image:url(&quot;/assets/czs-pen.svg&quot;)"></a><a class="czs-angle-up-l button" href="#" style="background-image:url(&quot;/assets/czs-angle-up-l.svg&quot;)"></a></div><script src="https://cdn.pagic.org/react@16.13.1/umd/react.production.min.js"></script><script src="https://cdn.pagic.org/react-dom@16.13.1/umd/react-dom.production.min.js"></script><script type="module" src="/index.js"></script></body></html>