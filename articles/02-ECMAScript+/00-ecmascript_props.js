import projectConfig from '/pagic.config.js';
var _a, _b;
export default {
    'prev': {
        "link": "articles/02-ECMAScript+/index.html",
        "title": "ECMAScript+"
    },
    'next': {
        "title": "JavaScript 基础知识",
        "link": "articles/02-ECMAScript+/01-javascript.html"
    },
    'sidebar': [
        {
            "title": "ESMAScript+ 面试宝典",
            "link": "articles/index.html",
            "pagePath": "articles/README.md"
        },
        {
            "title": "前端大事记",
            "link": "articles/es-timeline.html",
            "pagePath": "articles/es-timeline.md"
        },
        {
            "title": "ES 方向 & 谁在招人？",
            "link": "articles/es-direction.html",
            "pagePath": "articles/es-direction.md"
        },
        {
            "title": "职业 & 成长",
            "link": "articles/00-Profession/index.html",
            "pagePath": "articles/00-Profession/README.md"
        },
        {
            "link": "articles/01-Programming/index.html",
            "title": "编程基础",
            "children": [
                {
                    "title": "编程语言",
                    "link": "articles/01-Programming/00-language.html",
                    "pagePath": "articles/01-Programming/00-language.md"
                },
                {
                    "title": "操作系统",
                    "link": "articles/01-Programming/01-operating-system.html",
                    "pagePath": "articles/01-Programming/01-operating-system.md"
                },
                {
                    "title": "算法",
                    "link": "articles/01-Programming/02-algorithms.html",
                    "pagePath": "articles/01-Programming/02-algorithms.md"
                },
                {
                    "title": "设计模式",
                    "link": "articles/01-Programming/03-design-patterns.html",
                    "pagePath": "articles/01-Programming/03-design-patterns.md"
                },
                {
                    "title": "软件工程",
                    "link": "articles/01-Programming/04-software-engineering.html",
                    "pagePath": "articles/01-Programming/04-software-engineering.md"
                },
                {
                    "title": "测试",
                    "link": "articles/01-Programming/05-software-test.html",
                    "pagePath": "articles/01-Programming/05-software-test.md"
                },
                {
                    "title": "版本控制",
                    "link": "articles/01-Programming/06-version-control.html",
                    "pagePath": "articles/01-Programming/06-version-control.md"
                },
                {
                    "title": "计算机组成原理",
                    "link": "articles/01-Programming/07-computer-principles.html",
                    "pagePath": "articles/01-Programming/07-computer-principles.md"
                },
                {
                    "title": "编译原理",
                    "link": "articles/01-Programming/08-compilation-principle.html",
                    "pagePath": "articles/01-Programming/08-compilation-principle.md"
                }
            ],
            "pagePath": "articles/01-Programming/README.md"
        },
        {
            "link": "articles/02-ECMAScript+/index.html",
            "title": "ECMAScript+",
            "children": [
                {
                    "title": "ECMAScript",
                    "link": "articles/02-ECMAScript+/00-ecmascript.html",
                    "pagePath": "articles/02-ECMAScript+/00-ecmascript.md"
                },
                {
                    "title": "JavaScript 基础知识",
                    "link": "articles/02-ECMAScript+/01-javascript.html",
                    "pagePath": "articles/02-ECMAScript+/01-javascript.md"
                },
                {
                    "title": "TypeScript",
                    "link": "articles/02-ECMAScript+/02-typescript.html",
                    "pagePath": "articles/02-ECMAScript+/02-typescript.md"
                },
                {
                    "title": "JavaScript 常见实战题",
                    "link": "articles/02-ECMAScript+/03-javascript-parctice.html",
                    "pagePath": "articles/02-ECMAScript+/03-javascript-parctice.md"
                }
            ],
            "pagePath": "articles/02-ECMAScript+/README.md"
        },
        {
            "link": "articles/03-HTML+CSS/index.html",
            "title": "HTML + CSS",
            "children": [
                {
                    "title": "HTML",
                    "link": "articles/03-HTML+CSS/00-html.html",
                    "pagePath": "articles/03-HTML+CSS/00-html.md"
                },
                {
                    "title": "CSS",
                    "link": "articles/03-HTML+CSS/01-css-design.html",
                    "pagePath": "articles/03-HTML+CSS/01-css-design.md"
                },
                {
                    "title": "HTML + CSS 实战",
                    "link": "articles/03-HTML+CSS/02-html-css-practice.html",
                    "pagePath": "articles/03-HTML+CSS/02-html-css-practice.md"
                },
                {
                    "title": "DOM + BOM",
                    "link": "articles/03-HTML+CSS/03-dom-bom.html",
                    "pagePath": "articles/03-HTML+CSS/03-dom-bom.md"
                }
            ],
            "pagePath": "articles/03-HTML+CSS/README.md"
        },
        {
            "link": "articles/04-Network+API/index.html",
            "title": "网络 + 前后端协作",
            "children": [
                {
                    "title": "网络",
                    "link": "articles/04-Network+API/00-network.html",
                    "pagePath": "articles/04-Network+API/00-network.md"
                },
                {
                    "title": "前后端协作",
                    "link": "articles/04-Network+API/01-fe-be-api.html",
                    "pagePath": "articles/04-Network+API/01-fe-be-api.md"
                },
                {
                    "title": "网络安全",
                    "link": "articles/04-Network+API/02-network-security.html",
                    "pagePath": "articles/04-Network+API/02-network-security.md"
                }
            ],
            "pagePath": "articles/04-Network+API/README.md"
        },
        {
            "link": "articles/05-V8+Runtime/index.html",
            "title": "V8 + JavaScript 运行时",
            "children": [
                {
                    "title": "V8",
                    "link": "articles/05-V8+Runtime/00-v8.html",
                    "pagePath": "articles/05-V8+Runtime/00-v8.md"
                },
                {
                    "title": "Node",
                    "link": "articles/05-V8+Runtime/01-node.html",
                    "pagePath": "articles/05-V8+Runtime/01-node.md"
                },
                {
                    "title": "Deno",
                    "link": "articles/05-V8+Runtime/02-deno.html",
                    "pagePath": "articles/05-V8+Runtime/02-deno.md"
                }
            ],
            "pagePath": "articles/05-V8+Runtime/README.md"
        },
        {
            "link": "articles/06-FE+Browser/index.html",
            "title": "前端应用开发 + 浏览器",
            "children": [
                {
                    "title": "浏览器",
                    "link": "articles/06-FE+Browser/00-browser.html",
                    "pagePath": "articles/06-FE+Browser/00-browser.md"
                },
                {
                    "title": "前端工程化",
                    "link": "articles/06-FE+Browser/01-fe-engineering.html",
                    "pagePath": "articles/06-FE+Browser/01-fe-engineering.md"
                },
                {
                    "title": "前端工具链",
                    "link": "articles/06-FE+Browser/02-fe-tooltain.html",
                    "pagePath": "articles/06-FE+Browser/02-fe-tooltain.md"
                },
                {
                    "title": "前端打包工具",
                    "link": "articles/06-FE+Browser/03-pack-tool.html",
                    "pagePath": "articles/06-FE+Browser/03-pack-tool.md"
                },
                {
                    "title": "移动端 Web 开发",
                    "link": "articles/06-FE+Browser/04-fe-mobile.html",
                    "pagePath": "articles/06-FE+Browser/04-fe-mobile.md"
                },
                {
                    "title": "React",
                    "link": "articles/06-FE+Browser/05-react.html",
                    "pagePath": "articles/06-FE+Browser/05-react.md"
                },
                {
                    "title": "Vue",
                    "link": "articles/06-FE+Browser/06-vue.html",
                    "pagePath": "articles/06-FE+Browser/06-vue.md"
                },
                {
                    "title": "iframe",
                    "link": "articles/06-FE+Browser/07-iframe.html",
                    "pagePath": "articles/06-FE+Browser/07-iframe.md"
                }
            ],
            "pagePath": "articles/06-FE+Browser/README.md"
        },
        {
            "link": "articles/07-BE+Server/index.html",
            "title": "后端应用开发 + 服务器",
            "children": [
                {
                    "title": "Linux + Nginx + 数据库",
                    "link": "articles/07-BE+Server/00-linux-nginx-database.html",
                    "pagePath": "articles/07-BE+Server/00-linux-nginx-database.md"
                },
                {
                    "title": "Node 框架",
                    "link": "articles/07-BE+Server/01-node-framework.html",
                    "pagePath": "articles/07-BE+Server/01-node-framework.md"
                }
            ],
            "pagePath": "articles/07-BE+Server/README.md"
        },
        {
            "title": "如何用 Markdown 绘制图片",
            "link": "articles/draw-in-markdown.html",
            "pagePath": "articles/draw-in-markdown.md"
        },
        {
            "title": "变更日志",
            "link": "articles/roadmap.html",
            "pagePath": "articles/roadmap.md"
        }
    ],
    config: { "root": "/", ...projectConfig, ...(_b = (_a = projectConfig.i18n) === null || _a === void 0 ? void 0 : _a.overrides) === null || _b === void 0 ? void 0 : _b['undefined'] },
    'pagePath': "articles/02-ECMAScript+/00-ecmascript.md",
    'layoutPath': "_layout.tsx",
    'outputPath': "articles/02-ECMAScript+/00-ecmascript.html",
    'title': "ECMAScript",
    'content': React.createElement("article", { dangerouslySetInnerHTML: {
            __html: '<h1>ECMAScript</h1>\n<blockquote>\n<p>重点关注标准本身</p>\n</blockquote>\n<h2 id="%E6%A0%87%E5%87%86%E5%9F%BA%E7%A1%80">标准基础<a class="anchor" href="#%E6%A0%87%E5%87%86%E5%9F%BA%E7%A1%80">§</a></h2>\n<h3 id="es-%E6%A0%87%E5%87%86%E5%8F%8A%E5%85%B6%E6%B5%81%E7%A8%8B">ES 标准及其流程？<a class="anchor" href="#es-%E6%A0%87%E5%87%86%E5%8F%8A%E5%85%B6%E6%B5%81%E7%A8%8B">§</a></h3>\n<ul>\n<li>\n<p>ECMAScript 是 ECMA 制定的标准化脚本语言。</p>\n</li>\n<li>\n<p>ECMA 规范最终由 TC39 敲定。TC39 由包括浏览器厂商在内的各方组成，他们开会推动 JavaScript 提案沿着一条严格的发展道路前进。</p>\n</li>\n<li>\n<p>TC39 的新特性提案：<a href="https://github.com/tc39/proposals">https://github.com/tc39/proposals</a></p>\n</li>\n<li>\n<p>ECMAScript 新闻：<a href="https://www.ecma-international.org/news/index.html">https://www.ecma-international.org/news/index.html</a></p>\n</li>\n<li>\n<p>从提案到入选ECMA规范主要有以下几个阶段：</p>\n<ul>\n<li>Stage 0: strawman——最初想法的提交。</li>\n<li>Stage 1: proposal（提案）——由 TC39 至少一名成员倡导的正式提案文件，该文件包括 API 示例。</li>\n<li>Stage 2: draft（草案）——功能规范的初始版本，该版本包含功能规范的两个实验实现。</li>\n<li>Stage 3: candidate（候选）——提案规范通过审查并从厂商那里收集反馈。</li>\n<li>Stage 4: finished（完成）——提案准备加入 ECMAScript，但是到浏览器或者 Nodejs 中可能需要更长的时间。</li>\n</ul>\n</li>\n</ul>\n<h3 id="%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E4%BF%9D%E7%95%99%E5%AD%97%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B">关键字与保留字都有哪些？<a class="anchor" href="#%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E4%BF%9D%E7%95%99%E5%AD%97%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B">§</a></h3>\n<ul>\n<li>null：表示尚未存在的对象，是一种特殊的 object\n<ul>\n<li>作为函数的参数，表示该函数的参数不是对象。</li>\n<li>作为对象原型链的终点。</li>\n</ul>\n</li>\n</ul>\n<p>ECMA-262 定义了 ECMAScript 支持的一套关键字和一套保留字。如果把关键字用作变量名或函数名，可能得到诸如 &quot;Identifier Expected&quot;（应该有标识符、期望标识符）这样的错误消息。其中，关键字标识了 ECMAScript 语句的开头和/或结尾，保留字在某种意思上是为将来的关键字而保留的单词，因此关键字与保留字军不能被用作变量名或函数名。</p>\n<table>\n<thead>\n<tr>\n<th>JavaScript 关键字</th>\n<th>(待做待加入 ES6+)</th>\n<th></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>break</td>\n<td>case</td>\n<td>catch</td>\n<td>continue</td>\n<td>default</td>\n</tr>\n<tr>\n<td>delete</td>\n<td>do</td>\n<td>else</td>\n<td>finally</td>\n<td>for</td>\n</tr>\n<tr>\n<td>function</td>\n<td>if</td>\n<td>in</td>\n<td>instanceof</td>\n<td>new</td>\n</tr>\n<tr>\n<td>return</td>\n<td>switch</td>\n<td>this</td>\n<td>throw</td>\n<td>try</td>\n</tr>\n<tr>\n<td>typeof</td>\n<td>var</td>\n<td>void</td>\n<td>while</td>\n<td>with</td>\n</tr>\n<tr>\n<td>class(ES5)</td>\n<td>enum(ES5)</td>\n<td>export(ES5)</td>\n<td>import(ES5)</td>\n<td>super(ES5)</td>\n</tr>\n<tr>\n<td>extends(ES5)</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th>JavaScript 保留字</th>\n<th>(待做待加入 ES6+)</th>\n<th></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>abstract</td>\n<td>boolean</td>\n<td>byte</td>\n<td>char</td>\n<td>const</td>\n</tr>\n<tr>\n<td>debugger</td>\n<td>double</td>\n<td>final</td>\n<td>float</td>\n<td>goto</td>\n</tr>\n<tr>\n<td>implements</td>\n<td>int</td>\n<td>interface</td>\n<td>long</td>\n<td>native</td>\n</tr>\n<tr>\n<td>package</td>\n<td>private</td>\n<td>protected</td>\n<td>public</td>\n<td>short</td>\n</tr>\n<tr>\n<td>static</td>\n<td>synchronized</td>\n<td>throws</td>\n<td>transient</td>\n<td>volatile</td>\n</tr>\n</tbody>\n</table>\n<h3 id="%E6%A0%87%E8%AF%86%E7%AC%A6%E5%91%BD%E5%90%8D%E7%9A%84%E9%81%BF%E5%85%8D%E5%8E%9F%E5%88%99">标识符命名的避免原则？<a class="anchor" href="#%E6%A0%87%E8%AF%86%E7%AC%A6%E5%91%BD%E5%90%8D%E7%9A%84%E9%81%BF%E5%85%8D%E5%8E%9F%E5%88%99">§</a></h3>\n<ul>\n<li>避免使用一些 Java 对象和属性作为 JavaScript 标识符。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>Java 关键字示例</th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>getClass</td>\n<td>java</td>\n<td>JavaArray</td>\n</tr>\n<tr>\n<td>javaClass</td>\n<td>JavaObject</td>\n<td>JavaPackage</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>避免使用 HTML 和 Windows 对象属性和名称作为 JavaScript 标识符。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>HTML、Windows 对象属性和名称</th>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>alert</td>\n<td>all</td>\n<td>anchor</td>\n<td>anchors</td>\n<td>area</td>\n</tr>\n<tr>\n<td>assign</td>\n<td>blur</td>\n<td>button</td>\n<td>checkbox</td>\n<td>clearInterval</td>\n</tr>\n<tr>\n<td>clearTimeout</td>\n<td>clientInformation</td>\n<td>close</td>\n<td>closed</td>\n<td>confirm</td>\n</tr>\n<tr>\n<td>constructor</td>\n<td>crypto</td>\n<td>decodeURI</td>\n<td>decodeURIComponent</td>\n<td>defaultStatus</td>\n</tr>\n<tr>\n<td>document</td>\n<td>element</td>\n<td>elements</td>\n<td>embed</td>\n<td>embeds</td>\n</tr>\n<tr>\n<td>encodeURI</td>\n<td>encodeURIComponent</td>\n<td>escape</td>\n<td>event</td>\n<td>fileUpload</td>\n</tr>\n<tr>\n<td>focus</td>\n<td>form</td>\n<td>forms</td>\n<td>frame</td>\n<td>innerHeight</td>\n</tr>\n<tr>\n<td>innerWidth</td>\n<td>layer</td>\n<td>layers</td>\n<td>link</td>\n<td>location</td>\n</tr>\n<tr>\n<td>mimeTypes</td>\n<td>navigate</td>\n<td>navigator</td>\n<td>frames</td>\n<td>frameRate</td>\n</tr>\n<tr>\n<td>hidden</td>\n<td>history</td>\n<td>image</td>\n<td>images</td>\n<td>offscreenBuffering</td>\n</tr>\n<tr>\n<td>open</td>\n<td>opener</td>\n<td>option</td>\n<td>outerHeight</td>\n<td>outerWidth</td>\n</tr>\n<tr>\n<td>packages</td>\n<td>pageXOffset</td>\n<td>pageYOffset</td>\n<td>parent</td>\n<td>parseFloat</td>\n</tr>\n<tr>\n<td>parseInt</td>\n<td>password</td>\n<td>pkcs11</td>\n<td>plugin</td>\n<td>prompt</td>\n</tr>\n<tr>\n<td>propertyIsEnum</td>\n<td>radio</td>\n<td>reset</td>\n<td>screenX</td>\n<td>screenY</td>\n</tr>\n<tr>\n<td>scroll</td>\n<td>secure</td>\n<td>select</td>\n<td>self</td>\n<td>setInterval</td>\n</tr>\n<tr>\n<td>setTimeout</td>\n<td>status</td>\n<td>submit</td>\n<td>taint</td>\n<td>text</td>\n</tr>\n<tr>\n<td>textarea</td>\n<td>top</td>\n<td>unescape</td>\n<td>untaint</td>\n<td>window</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>避免使用 HTML 事件句柄作为 JavaScript 标识符。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>onblur</td>\n<td>onclick</td>\n<td>onerror</td>\n<td>onfocus</td>\n</tr>\n<tr>\n<td>onkeydown</td>\n<td>onkeypress</td>\n<td>onkeyup</td>\n<td>onmouseover</td>\n</tr>\n<tr>\n<td>onload</td>\n<td>onmouseup</td>\n<td>onmousedown</td>\n<td>onsubmit</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>避免使用非标准 JavaScript 的关键字</li>\n</ul>\n<p>一个实例是 const 关键字，用于定义变量。一些 JavaScript 引擎把 const 当作 var 的同义词。另一些引擎则把 const 当作只读变量的定义。Const 是 JavaScript 的扩展。JavaScript 引擎支持它用在 Firefox 和 Chrome 中。但是它并不是 JavaScript 标准 ES3 或 ES5 的组成部分。建议：不要使用它。</p>\n<h3 id="es-5-%E7%89%B9%E6%80%A7%E5%8F%91%E5%B1%95%E5%8F%B2">ES ~5 特性发展史？<a class="anchor" href="#es-5-%E7%89%B9%E6%80%A7%E5%8F%91%E5%B1%95%E5%8F%B2">§</a></h3>\n<h3 id="es-6-%E6%96%B0%E7%89%B9%E6%80%A7%E6%A6%82%E8%A6%81">ES 6+ 新特性概要？<a class="anchor" href="#es-6-%E6%96%B0%E7%89%B9%E6%80%A7%E6%A6%82%E8%A6%81">§</a></h3>\n<blockquote>\n<p>以下特性摘抄自博客，尚未和 ES 标准精确配对，可能会出现特性和版本不一致。</p>\n</blockquote>\n<ul>\n<li>ES6：在 ES5 发布近 6 年（2009-11 至 2015-6）之后才将其标准化。\n<ul>\n<li><strong>类</strong>：<code>class; new; instanceof; constructor;</code>。</li>\n<li><strong>模块化</strong>：<code>export; import;</code>。</li>\n<li><strong>箭头函数</strong>：箭头函数与包围它的代码共享同一个 this。<code>() =&gt; {}; fun.bind(this);</code>。</li>\n<li><strong>函数参数默认值</strong>：<code>function foo(h = 50, c = \'red\') {};</code>。</li>\n<li><strong>模板字符串</strong>：`Your name is ${first} ${last}`;。</li>\n<li><strong>解构赋值</strong>：<code>[a=5, b=7] = [1];  [a, b] = [b, a]; const { n, a } = s;</code>。</li>\n<li><strong>延展操作符</strong>：<code>[...[1, 2]]; [...obj, \'4\', ...\'hello\', 6];</code>。</li>\n<li><strong>对象属性简写</strong>：<code>student = { name };</code>。</li>\n<li><strong>Promise</strong>：异步编程串行化，避免了回调地狱。<code>new Promise((resolve, reject) =&gt; {});</code>。</li>\n<li><strong>Let 与 Const</strong>：填补块级作用域空白。</li>\n</ul>\n</li>\n<li>ES7：来说明标准化的过程\n<ul>\n<li><strong>Array.prototype.includes()</strong>：判断一个数组是否包含一个指定的值。</li>\n<li><strong>指数操作符</strong>：具有与 Math.pow(..) 相同的效果。<code>console.log(2**10);</code>。</li>\n</ul>\n</li>\n<li>ES8：\n<ul>\n<li><strong>[升级] 延展操作符</strong>：增加了对对象的支持，<code>let objClone = { ...obj }; </code>。</li>\n<li><strong>Async/Await</strong>：异步迭代器。</li>\n<li><strong>Object.values()</strong>：与 Object.keys() 类似，返回 Object 自身属性的所有值，不包括继承的值。</li>\n<li><strong>Object.entries()</strong>：返回一个给定对象自身可枚举属性的键值对的数组。<code>for(let [k,v] of Object.entries(obj)) {}</code>。</li>\n<li><strong>String padding</strong>：填充字符串达到当前长度。<code>String.prototype.padStart; String.prototype.padEnd;</code>。</li>\n<li><strong>函数参数列表结尾允许逗号</strong>：git 修改同一个函数减少不必要的行变更。</li>\n<li><strong>Object.getOwnPropertyDescriptors()</strong>：获取一个对象的所有自身属性的描述符,如果没有任何自身属性，则返回空对象。</li>\n<li><strong>ShareArrayBuffer</strong>：类似于 ArrayBuffer，表示一个通用的，固定长度的原始二进制数据缓冲区，但 SharedArrayBuffer 不能被分离。<code>new SharedArrayBuffer(length)</code>。</li>\n<li><strong>Atomics</strong>：提供了一组静态方法用来对 SharedArrayBuffer 对象进行原子操作（多线程共同读写时保证符合预期）。Atomics 的所有属性和方法都是静态的（与 Math 对象一样）。</li>\n</ul>\n</li>\n<li>ES9：\n<ul>\n<li><strong>[升级] 异步迭代器</strong>：Async/Await。<code>for await (let i of arr) {}; arr.forEach(async i =&gt; { await fun(i); }); </code>。</li>\n<li><strong>[升级] Promise.finally()</strong>：指定多个 Promise 统一执行完后最终的逻辑，不关注每一个的成功状态。</li>\n<li><strong>[升级] Rest/Spread 属性</strong>：允许我们将一个不定数量的参数表示为一个数组，只适用于每个对象的顶层而非嵌套。<code>restParam(p1, p2, ...p3)</code>。</li>\n<li><strong>正则表达式命名捕获组</strong>：<code>const reDate = /(?&lt;year&gt;[0-9]{4})-(?&lt;month&gt;[0-9]{2})-(?&lt;day&gt;[0-9]{2}); const usDate = \'2020-10-01\'.replace(reDate, \'$&lt;month&gt;-$&lt;day&gt;-$&lt;year&gt;\');</code>。</li>\n<li><strong>正则表达式反向断言</strong>：分为肯定反向断言，否定反向断言。</li>\n<li><strong>正则表达式 dotAll 模式</strong>：<code>.</code> 匹配除回车外的任何单字符，标记 <code>s</code> 改变这种行为，允许行终止符的出现。<code>/hello.world/s.test(\'hello\nworld\');</code>。</li>\n<li><strong>正则表达式 Unicode 转义</strong>：添加了 Unicode 属性转义——形式为 <code>\p{...}</code> 和 <code>\P{...}</code></li>\n<li><strong>非转义序列的模板字符串</strong>。</li>\n</ul>\n</li>\n<li><a href="https://ecma-international.org/publications/standards/Ecma-417.htm">ES10（ES 2019，ECMA-417）</a>：\n<ul>\n<li>**行分隔符（U + 2028）和段分隔符（U + 2029）**符号现在允许在字符串文字中，与 JSON 匹配。以前这些符号在字符串文字中被视为行终止符，使用它们会导致 SyntaxError 异常。</li>\n<li><strong>[升级] JSON.stringify</strong>：和 Unicode 有关。</li>\n<li><strong>Array.flat() 和 Array.flatMap()</strong>：本质上就是是归纳（reduce） 与 合并（concat）的操作。</li>\n<li><strong>String.trimStart() 和 String.trimEnd()</strong>：分别去除字符串首尾空白字符。</li>\n<li><strong>Object.fromEntries()</strong>：<code>Object.entries()</code> 返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 for...in 循环遍历该对象时返回的顺序一致。<code>Object.fromEntries()</code> 则是 <code>Object.entries()</code> 的反转。可以将 Map 或 Array 转化为 Object。</li>\n<li><strong>Symbol.prototype.description</strong>：直接访问 Symbol(\'The description\') 后的内容，使用 <code>sym.description</code> 而非 <code>String(sym.desc)</code>。</li>\n<li><strong>String.prototype.matchAll</strong>：查找字符串中所有正则表达式的匹配项和它们的位置。<code>str.matchAll(regexp)</code>。</li>\n<li><strong>Function.prototype.toString()</strong>：现在返回精确字符，包括空格和注释。<code>console.log(foo.toString()); // function /* comment */ foo /* another comment */ (){}</code>。</li>\n<li><strong>修改 catch 绑定</strong>：简化 <code>try {} catch(e) {}</code> 为 <code>try {} catch {}</code>。</li>\n<li><strong>BigInt</strong>：新的基本数据类型。创建比 2^53 - 1 还大的数，typeof 值为 bigint。<code>BigInt(1); 1n</code>。</li>\n<li><strong>globalThis</strong>：统一浏览器的 window 和 node 中的 global。</li>\n</ul>\n</li>\n<li><a href="https://www.ecma-international.org/publications/standards/Ecma-262.htm">ES11（ES 2020，ECMA-262）</a>：\n<ul>\n<li><strong>Optional Chaining 可选链式调用</strong>：<code>flower.species?.lily; flowers?.[1]; plantFlowers?.()</code>。</li>\n<li><strong>Nullish Coalescing 空值合并</strong>：<code>number ?? 7</code>。</li>\n<li><strong>Private Fields 私有字段</strong>：ES6 支持类语法，ES11 才引人私有字段，符号为 <code>#</code>。</li>\n<li><strong>Static Fields 静态字段</strong>：想使用类的方法，必须先实例化一个类，除非此方法为 static。</li>\n<li><strong>Top Level Await 顶级 Await</strong>：此前在顶级 await 必须使用 IIFE，现在直接顶级使用。</li>\n<li><strong>Promise.allSettled 方法</strong>：可以不关心数组中每个的 Promise 是否成功或失败，统一处理。<code>Promise.allSettled([a, b]).then(([a, b]) =&gt; {})</code>。</li>\n<li><strong>Dynamic Import 动态引入</strong>：<code>import(\'\').then()</code>。</li>\n</ul>\n</li>\n</ul>\n<h3 id="es5-%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F">[ES5] 什么是严格模式？<a class="anchor" href="#es5-%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F">§</a></h3>\n<ul>\n<li>\n<p>\'use strict\' 是用于对整个脚本或单个函数启用严格模式的语句。严格模式是可选择的一个限制 JavaScript 的变体的一种方式。</p>\n</li>\n<li>\n<p>正常模式下，Javascript语言有两种变量作用域（scope）：全局作用域和函数作用域。严格模式创设了第三种作用域：eval作用域。</p>\n<ul>\n<li>严格模式下，eval 语句本身就是一个作用域，不再能够生成全局变量了，它所生成的变量只能用于 eval 内部。</li>\n</ul>\n</li>\n<li>\n<p>诞生目的：</p>\n<ul>\n<li>消除 Javascript 语法的一些不合理、不严谨之处，减少一些怪异行为;</li>\n<li>消除代码运行的一些不安全之处，保证代码运行的安全；</li>\n<li>提高编译器效率，增加运行速度；</li>\n<li>为未来新版本的 Javascript 做好铺垫。</li>\n</ul>\n</li>\n<li>\n<p>语法和行为的改变：</p>\n<ul>\n<li>全局变量必须显式声明。</li>\n<li>某些情况只允许静态绑定，以在编译阶段确定属性和方法的归属：禁止使用 with 语句、创设eval作用域。</li>\n<li>增强的安全措施：禁止 this 关键字指向全局对象、禁止在函数内部遍历调用栈。</li>\n<li>禁止删除变量。只能删除 configurable 为 true 的对象属性。</li>\n<li>显式报错：\n<ul>\n<li>会引起静默失效（即不报错也没有任何效果）的赋值抛出异常。</li>\n<li>对只读属性进行赋值会显式的报错。</li>\n<li>对一个使用 getter 方法读取的属性进行赋值会报错。</li>\n<li>对禁止扩展的对象添加新属性会报错。</li>\n<li>删除一个不可删除的属性，会报错。只有 configurable 设置为 true 的对象属性，才能被删除。<code>Object.create(null, { \'x\': { configurable: true }});</code></li>\n</ul>\n</li>\n<li>重名错误：对象不能有重名的属性、函数不能有重名的参数</li>\n<li>禁止八进制表示</li>\n<li>arguments 对象的限制：\n<ul>\n<li>不允许对 arguments 赋值</li>\n<li>arguments不再追踪参数的变化</li>\n<li>禁止使用 arguments.callee</li>\n</ul>\n</li>\n<li>函数必须声明在顶层：不允许在非函数的代码块内声明函数。如 <code>if</code> 中。</li>\n<li>新增了一些保留字（向后兼容）：implements, interface, let, package, private, protected, public, static, yield。</li>\n</ul>\n</li>\n<li>\n<p>注意：</p>\n<ul>\n<li>无法访问 function.caller 和 function.arguments。</li>\n<li>以不同严格模式编写的脚本合并后可能导致问题。\n<ul>\n<li>解决办法：将整个脚本文件包含在 IIFE 中， 并声明 <code>&quot;use strict&quot;</code>。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id="%E6%A8%A1%E5%9D%97%E5%8C%96">模块化<a class="anchor" href="#%E6%A8%A1%E5%9D%97%E5%8C%96">§</a></h2>\n<blockquote>\n<p>重点关注标准、基础数据类型、新 API 特性</p>\n</blockquote>\n<h3 id="es-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%8F%91%E5%B1%95%E5%8F%B2">ES 模块化发展史<a class="anchor" href="#es-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%8F%91%E5%B1%95%E5%8F%B2">§</a></h3>\n<ul>\n<li>社区解决方案 - 同步服务端 CommonJS &amp; Node.js：\n<ul>\n<li>暴露模块 - <code>module.exports</code>。</li>\n<li>暴露模块 - <code>exports</code>。</li>\n<li>加载模块 - <code>require()</code>。</li>\n</ul>\n</li>\n<li>社区解决方案 - 异步浏览器 AMD &amp; RequireJS：\n<ul>\n<li>定义：<code>define(id?, dependencies?, factory);</code>。</li>\n<li>加载：<code>require([module], callback);</code>。</li>\n</ul>\n</li>\n<li>社区解决方案 - 异步就近加载 CMD &amp; SeaJS：\n<ul>\n<li>定义：<code>define(id?, dependencies?, factory);</code>。</li>\n<li>依赖就近，用的时候再 <code>require</code>。</li>\n<li>需要使用把模块变为字符串解析一遍才知道依赖了那些模块。</li>\n</ul>\n</li>\n<li>官方解决方案 - ES6 import/export：\n<ul>\n<li>导出 - 命名式导出。</li>\n<li>导出 - 默认导出：<code>export default {};</code>。</li>\n<li>导入：对应导出的命名式导出和默认导出。<code>import $, {each, map} from \'jquery\';</code>。</li>\n</ul>\n</li>\n</ul>\n<h3 id="es-%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9A%84%E5%85%B7%E4%BD%93%E7%89%B9%E6%80%A7">ES 模块化的具体特性？<a class="anchor" href="#es-%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9A%84%E5%85%B7%E4%BD%93%E7%89%B9%E6%80%A7">§</a></h3>\n<ul>\n<li>import, require 有什么不同的表现形式？</li>\n<li>为什么说 ES6 的模块化是静态可分析的？-&gt; Tree Shaking</li>\n</ul>\n<pre class="language-autoit"><code class="language-autoit">Module Syntax\nModule <span class="token punctuation">:</span>\n     ModuleBody\nModuleBody <span class="token punctuation">:</span>\n     ModuleItemList\nModuleItemList <span class="token punctuation">:</span>\n     ModuleItem\n     ModuleItemList ModuleItem\nModuleItem <span class="token punctuation">:</span>\n     ImportDeclaration\n     ExportDeclaration\n     StatementListItem\n</code></pre>\n<ul>\n<li>模块化概念\n<ul>\n<li>命名空间：命名空间当前并非 JavaScript 一部分</li>\n<li>匿名函数表达式</li>\n<li>对象字面量</li>\n<li>闭包：从技术角度来讲，所有函数都是闭包</li>\n</ul>\n</li>\n<li>模块化意义\n<ul>\n<li>避免命名冲突</li>\n<li>保护代码完整性</li>\n<li>隐藏复杂性</li>\n<li>降低代码改变带来的冲击</li>\n<li>代码组织</li>\n</ul>\n</li>\n<li>模块化缺点：不能测试私有部分、拓展对象</li>\n<li>模块化编程\n<ul>\n<li>重要思想：通过模块模式来内化逻辑复杂性，并提供公有 API，这是 JavaScript 的封装实现方式</li>\n<li>模块对于 JavaScript 而言是特殊的构造函数，该类型函数通常被称为 IIFE 立即调用函数表达式</li>\n<li>模块内部返回带有公有函数的对象字面量，该对象字面量作为模块的公有 API</li>\n<li>典型模块模式：使用全局变量作为模块模式</li>\n<li>揭示模式：简化了返回的对象（API）</li>\n<li>对于 AMD/CommonJS 模块，不需要赋值给全局变量</li>\n<li>广义上，作用域指应用的某部分到相同应用另一部分的可达性</li>\n<li>坚持使用 SRP 单一职责原则设计模块</li>\n</ul>\n</li>\n<li>模块间交互方式\n<ul>\n<li>直接通过模块 API 交互\n<ul>\n<li>A 直接调用 B 的 API 与 B 交互，B 被称为 A 的依赖</li>\n<li>传统模块模式：在模块尾部括号内声明依赖，并通过参数访问列表来访问这些依赖</li>\n</ul>\n</li>\n<li>通过发布/订阅模式的事件聚合模式的方式\n<ul>\n<li>基于经典的观察者模式：observable 广播给 observer</li>\n<li>发布/订阅模式通常由一个中间服务代表另一个对象发布</li>\n<li>分为基本通知类型、带有数据的通知类型</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>模块加载及依赖管理\n<ul>\n<li>将模块合并到尽可能少的文件中去</li>\n<li>异步模块 AMD\n<ul>\n<li>define 声明模块</li>\n<li>require 导入模块</li>\n</ul>\n</li>\n<li>RequireJS 基础知识\n<ul>\n<li>data-main 入口</li>\n<li>requirejs.config()</li>\n<li>baseURL</li>\n<li>path</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id="%E4%BB%80%E4%B9%88%E6%98%AF%E6%A8%A1%E5%9D%97%E6%A8%A1%E5%BC%8F">什么是模块模式<a class="anchor" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%A8%A1%E5%9D%97%E6%A8%A1%E5%BC%8F">§</a></h3>\n<ul>\n<li>在模块内部功能与公开功能之间划定了清晰界限</li>\n<li>可访问性控制</li>\n<li>创建公有 API\n<ul>\n<li>返回对象字面量</li>\n<li>让函数立即返回</li>\n<li>闭包构造</li>\n</ul>\n</li>\n<li>允许全局导入\n<ul>\n<li>使得代码易读</li>\n<li>加速解释器的变量解释过程</li>\n</ul>\n</li>\n<li>优良特性\n<ul>\n<li>用模块封装内部代码，避免变量及函数污染全局命名空间</li>\n<li>创建应用编程接口，提供对内部功能的访问控制</li>\n</ul>\n</li>\n<li>创建模块的命名空间</li>\n</ul>\n<pre class="language-autoit"><code class="language-autoit"><span class="token operator">/</span><span class="token operator">/</span> 创建模块的命名空间\nvar moduleName <span class="token operator">=</span> <span class="token punctuation">(</span>function <span class="token punctuation">(</span><span class="token punctuation">)</span> {\n    var someVar<span class="token comment">;</span>\n    <span class="token operator">/</span><span class="token operator">/</span> 整体闭包构造\n    function someFunction <span class="token punctuation">(</span><span class="token punctuation">)</span> {\n    }\n    return {\n        <span class="token operator">/</span><span class="token operator">/</span> 返回 对象字面量\n        someFunction<span class="token punctuation">:</span> someFunction\n    }\n}<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">; // IIFE</span>\n</code></pre>\n<h2 id="%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">数据类型<a class="anchor" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">§</a></h2>\n<h3 id="%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B">基础数据类型都有哪些？<a class="anchor" href="#%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B">§</a></h3>\n<ul>\n<li>undefiend 没有定义数据类型</li>\n<li>number 数值数据类型，例如 10 或者 1 或者 5.5\n<ul>\n<li>NaN 是一种特殊的 number</li>\n</ul>\n</li>\n<li>string 字符串数据类型用来描述文本，例如 &quot;你的姓名&quot;\n<ul>\n<li>string 的内置属性和方法：</li>\n<li>构造函数 String()</li>\n</ul>\n</li>\n<li>boolean 布尔类型 true | false ，不是正就是反\n<ul>\n<li>boolean 的内置属性和方法：</li>\n<li>构造函数</li>\n</ul>\n</li>\n<li>object 对象类型，复杂的一组描述信息的集合\n<ul>\n<li>null 是一种特殊的 object</li>\n<li>object 的内置属性和方法：</li>\n<li>构造函数</li>\n<li>Object.prototype</li>\n</ul>\n</li>\n<li>function 函数类型\n<ul>\n<li>函数的内置属性和方法：</li>\n<li>构造函数</li>\n<li>Function.prototype</li>\n</ul>\n</li>\n</ul>\n<h3 id="string-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C">String 有哪些操作？<a class="anchor" href="#string-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C">§</a></h3>\n<h3 id="boolean-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C">Boolean 有哪些操作？<a class="anchor" href="#boolean-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C">§</a></h3>\n<h3 id="undifinednull-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C">Undifined/NULL 有哪些操作？<a class="anchor" href="#undifinednull-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C">§</a></h3>\n<h3 id="function-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C">Function 有哪些操作？<a class="anchor" href="#function-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C">§</a></h3>\n<h3 id="object-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C">Object 有哪些操作？<a class="anchor" href="#object-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C">§</a></h3>\n<h3 id="number-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C">Number 有哪些操作？<a class="anchor" href="#number-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C">§</a></h3>\n<ul>\n<li>\n<p>JS 的 Number 类型遵循的是 IEEE 754 标准，使用的是 64 位固定⻓度来表示。</p>\n</li>\n<li>\n<p>IEEE 754 浮点数由三个域组成，分别为 sign bit (符号位)、exponent bias (指数偏移值) 和 fraction (分数值)。64 位中，sign bit 占 1 位，exponent bias 占 11 位，fraction 占 52 位。</p>\n</li>\n<li>\n<p>以 0.1 转换为 IEEE 754 标准表示为例解释一下如何求 exponent bias 和 fraction。转换过程主要经历 3 个过程：</p>\n<ul>\n<li>将 0.1 转换为二进制表示。</li>\n<li>将转换后的二进制通过科学计数法表示。</li>\n<li>将通过科学计数法表示的二进制转换为 IEEE 754 标准表示。</li>\n</ul>\n</li>\n</ul>\n<h3 id="array-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C">Array 有哪些操作？<a class="anchor" href="#array-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C">§</a></h3>\n<ul>\n<li>Array 静态方法：<code>Array.from(); Array.isArray(); Array.of();</code>。</li>\n<li>Array 原型方法：\n<ul>\n<li><code>.concat(); .copyWithin(); .entries(); .every();</code>。</li>\n<li><code>.fill(); .filter(); .find(); .findIndex(); .flat(); .flatMap(); .forEach();</code>。</li>\n<li><code>.includes(); .indexOf(); .join(); .keys(); .lastIndexOf(); .map(); .pop(); .push(); </code>。</li>\n<li><code>.reduce(); .reduceRight(); .reverse(); .shift(); .slice(); .some(); .sort(); .splice(); </code>。</li>\n<li><code>.toLocaleString(); .toSource(); .toString(); .unshift(); .values();</code>。</li>\n<li><code>Array.prototype[@@iterator](); get Array[@@species]</code>。</li>\n</ul>\n</li>\n<li>Array 常见考题：\n<ul>\n<li>数组拷贝。</li>\n<li>数组展开。</li>\n<li>用 reduce 实现 map 的功能</li>\n<li>类数组转化成数组的方法</li>\n<li>实现数组 flatten</li>\n</ul>\n</li>\n<li>Object 常见考题：\n<ul>\n<li>深拷贝、浅拷贝</li>\n<li>如何判断一个对象是不是空对象？</li>\n</ul>\n</li>\n<li>类数组和数组的互相转换？</li>\n<li>Number &amp; BigInt 常见考题：\n<ul>\n<li>大数操作</li>\n<li>0.1+0.2 == 0.3？原因？</li>\n</ul>\n</li>\n<li>链式调用：add(2, 5)，add(2)(5)，add(1)(1)(5) 的结果都为 7</li>\n</ul>\n<h3 id="bigint-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C">BigInt 有哪些操作？<a class="anchor" href="#bigint-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C">§</a></h3>\n<ul>\n<li>JavaScript中Number.MAX_SAFE_INTEGER表示最大安全数字,计算结果是9007199254740991，即在这个数范围内不会出现精度丢失(小数除外)。 但是一旦超过这个范围，js就会出现计算不准确的情况，这在大数计算的时候不得不依靠一些第三方库进行解决，因此官方提出了BigInt来解决此问题。</li>\n</ul>\n<h3 id="%E4%BB%80%E4%B9%88%E6%98%AF%E5%85%B3%E8%81%94%E6%95%B0%E7%BB%84">什么是关联数组？<a class="anchor" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%85%B3%E8%81%94%E6%95%B0%E7%BB%84">§</a></h3>\n<blockquote>\n<p>其它多数语言里，数组分为索引数组和关联数组，索引数组又分为一维数组、二维数组和多维数组。</p>\n<p>引用：“JavaScript 里面没有关联数组和索引数组这两种不同的区分，一切对象都是键值对，数组也是对象，数组也可以看作是键值对。”</p>\n<p>自我感悟，存疑：JavaScript 还是有索引数组和关联数组的微小差异。索引数组和 length 属性直接挂钩，关联数组其实访问的是数组上的属性及其值，length 一般都是 0(没有真正的数据内容)。</p>\n</blockquote>\n<p>在计算机科学中，关联数组（英语：Associative Array），又称映射（Map）、字典（Dictionary）是一个抽象的数据结构，它包含着类似于（键，值）的有序对。一个关联数组中的有序对可以重复（如C中的 multimap）也可以不重复（如 C 中的 map）。这种数据结构包含以下几种常见的操作：</p>\n<ul>\n<li>向关联数组添加配对</li>\n<li>从关联数组内删除配对</li>\n<li>修改关联数组内的配对</li>\n<li>根据已知的键寻找配对</li>\n</ul>\n<blockquote>\n<p>字典问题是设计一种能够具备关联数组特性的数据结构。解决字典问题的常用方法，是利用散列表，但有些情况下，也可以直接使用二叉查找树或其他结构。</p>\n<p>许多程序设计语言内置基本的数据类型，提供对关联数组的支持。而内容定址存储器则是硬件层面上实现对关联数组的支持。</p>\n</blockquote>\n<p>属性值和键值的异同</p>\n<ul>\n<li>属性和键值不一样，给数组新增一个属性，其依然为数组，length 不变，新增的被读取时将是属性值，而非键值。</li>\n</ul>\n<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 定义一个数组</span>\n<span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 结果为3</span>\n\na<span class="token punctuation">[</span><span class="token string">"name"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"xiaoming"</span><span class="token punctuation">;</span> <span class="token comment">// 我们再给它赋值，这是给 a 数组增加了一个属性叫 name，而不是在数组里添加数据。</span>\n<span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [1, 2, 3, aaa: 1]，a 依然是数组</span>\n<span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 结果还是为 3</span>\n\na<span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">// [1, 2, 3, 4, aaa: 1]，a 依然是数组</span>\n<span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 结果为4</span>\n</code></pre>\n<ul>\n<li>以下两种写法效果是一样的，但 j2 符合 JSON 风格，当 JSON 对象作为 Map(映射、关联数组) 时使用。\n<ul>\n<li>JSON 对象和 JSON Map 在运行时看起来是一样的；这个特性与 API 设计相关。当 JSON 对象被当作 Map 使用时，API 文件应当做出说明。</li>\n<li>Map 的键名不一定要遵循属性名称的命名准则。键名可以包含任意的 Unicode 字符。客户端可使用 Map 熟悉的方括号来访问这些属性。</li>\n</ul>\n</li>\n</ul>\n<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">var</span> j1 <span class="token operator">=</span> <span class="token punctuation">{</span>\n    name<span class="token operator">:</span> <span class="token string">\'j1\'</span><span class="token punctuation">,</span>\n    age<span class="token operator">:</span> <span class="token number">18</span><span class="token punctuation">,</span>\n    <span class="token function-variable function">fun</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">var</span> j2 <span class="token operator">=</span> <span class="token punctuation">{</span>\n    <span class="token string">"name"</span><span class="token operator">:</span> <span class="token string">"j2"</span><span class="token punctuation">,</span>\n    <span class="token string">"age"</span><span class="token operator">:</span> <span class="token number">18</span><span class="token punctuation">,</span>\n    <span class="token string">"fun"</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>遍历关联数组</p>\n<pre class="language-javascript"><code class="language-javascript"><span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> key <span class="token keyword">in</span> array<span class="token punctuation">)</span><span class="token punctuation">{</span>  \n    <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token string">"键:"</span><span class="token punctuation">,</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>  \n    <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token string">"值:"</span><span class="token punctuation">,</span>array<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> \n<span class="token punctuation">}</span>\n</code></pre>\n<p>关联数组和索引数组的遍历效率问题。</p>\n<p>遍历赋值以下数组时，第一次耗费时间差不多，浏览器默认优化之后，arr2 作为 Array 而非 Object 存取速度更快。</p>\n<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token number">50000000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">var</span> arr2 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\n</code></pre>\n<h3 id="%E4%BB%80%E4%B9%88%E6%98%AF-json">什么是 JSON？<a class="anchor" href="#%E4%BB%80%E4%B9%88%E6%98%AF-json">§</a></h3>\n<ul>\n<li>\n<p>JSON 对象包含两个方法：</p>\n<ul>\n<li>用于解析 JavaScript Object Notation  (JSON) 的 parse() 方法</li>\n<li>以及将对象/值转换为 JSON 字符串的 stringify() 方法。</li>\n<li>除了这两个方法, JSON 这个对象本身并没有其他作用，也不能被调用或者作为构造函数调用。</li>\n<li>把数据结构或者对象转换成某种格式的过程称为「序列化」</li>\n<li>而将序列化过程的结果反向转换回某种数据结构或对象的过程称为「反序列化」。</li>\n</ul>\n</li>\n<li>\n<p>JSON 的本质</p>\n<ul>\n<li>JSON 指的是 JavaScript 对象表示法（JavaScript Object Notation）</li>\n<li>JSON 是轻量级的文本数据交换格式</li>\n<li>JSON 独立于语言，JSON 解析器和 JSON 库支持许多不同的编程语言。</li>\n<li>JSON 具有自我描述性，更易理解</li>\n</ul>\n</li>\n<li>\n<p>JSON 风格指南：</p>\n<ul>\n<li>所有的属性名必须在双引号内。</li>\n<li>JSON对象中不包含注释。</li>\n<li>JSON中的数据元素应以扁平化方式呈现。不能为了方便而将数据任意分组。</li>\n<li>选择有意义的属性名。</li>\n</ul>\n<ul>\n<li>\n<ul>\n<li>属性名应该是具有定义语义的有意义的名称。</li>\n<li>属性名必须是驼峰式的，ASCII 码字符串。</li>\n<li>首字符必须是字母，下划线(_)或美元符号($)。</li>\n<li>随后的其他字符可以是字母，数字，下划线(_)或美元符号($)。</li>\n<li>应该避免使用 Javascript 中的保留关键字</li>\n</ul>\n</li>\n<li>\n<p>在 JSON Map 中键名可以使用任意 Unicode 字符。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id="js-%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%9E%8B-%E4%B8%8E-json-%E7%9A%84%E5%8C%BA%E5%88%AB">JS 常见类型 与 JSON 的区别？<a class="anchor" href="#js-%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%9E%8B-%E4%B8%8E-json-%E7%9A%84%E5%8C%BA%E5%88%AB">§</a></h3>\n<table>\n<thead>\n<tr>\n<th>JavaScript类型</th>\n<th>JSON 的不同点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>对象和数组</td>\n<td>属性名称必须是双引号括起来的字符串；最后一个属性后不能有逗号。</td>\n</tr>\n<tr>\n<td>数值</td>\n<td>禁止出现前导零（ JSON.stringify 方法自动忽略前导零，而在 JSON.parse 方法中将会抛出 SyntaxError）；如果有小数点, 则后面至少跟着一位数字。</td>\n</tr>\n<tr>\n<td>字符串</td>\n<td>只有有限的一些字符可能会被转义；禁止某些控制字符； Unicode 行分隔符 （U+2028）和段分隔符 （U+2029）被允许 ; 字符串必须用双引号括起来。请参考下面的示例，可以看到 JSON.parse() 能够正常解析，但将其当作JavaScript解析时会抛出 SyntaxError 错误：</td>\n</tr>\n</tbody>\n</table>\n<pre class="language-autoit"><code class="language-autoit">let code <span class="token operator">=</span> <span class="token string">\'"\u2028\u2029"\'</span><span class="token comment">;</span>\nJSON<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>code<span class="token punctuation">)</span><span class="token comment">;  // 正常</span>\n<span class="token function">eval</span><span class="token punctuation">(</span>code<span class="token punctuation">)</span><span class="token comment">;  // 错误</span>\n</code></pre>\n<ul>\n<li>JSON.parse()：解析 JSON 字符串并返回对应的值，可以额外传入一个转换函数，用来将生成的值和其属性, 在返回之前进行某些修改。</li>\n<li>JSON.stringify()：返回与指定值对应的JSON字符串，可以通过额外的参数, 控制仅包含某些属性, 或者以自定义方法来替换某些 key 对应的属性值。</li>\n<li>JSON Polyfill：JSON 对象可能不被老版本的浏览器支持。可以将下面的代码放到JS脚本最开始的位置，这样就可以在没有原生支持 JSON 对象的浏览器（如IE6）中使用 JSON 对象。</li>\n</ul>\n<h2 id="%E6%96%B0%E7%89%B9%E6%80%A7-api">新特性 API<a class="anchor" href="#%E6%96%B0%E7%89%B9%E6%80%A7-api">§</a></h2>\n<h3 id="%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3-promise-api">如何理解 Promise API？<a class="anchor" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3-promise-api">§</a></h3>\n<ul>\n<li>同步函数与异步函数\n<ul>\n<li>同步函数阻塞，语句完成后，下一句才执行。</li>\n<li>异步函数不阻塞，通常接受回调作为参数，在调用异步函数后立即继续执行下一行。回调函数仅在异步操作完成且调用堆栈为空时调用。</li>\n</ul>\n</li>\n<li>Promise 是一个可能在未来某个时间产生结果的对象：操作成功的结果或失败的原因。Promise 可能处于以下三种状态之一：fulfilled、rejected、pending。用户可以对 Promise 添加回调函数来处理操作成功的结果或失败的原因。</li>\n<li>Promise 代替回调函数的优点：\n<ul>\n<li>避免可读性极差的回调地狱。</li>\n<li>使用 .then() 编写的顺序异步代码，既简单又易读。</li>\n<li>使用 Promise.all() 编写异步代码变得很容易。</li>\n</ul>\n</li>\n<li>Promise 代替回调函数的缺点：</li>\n</ul>\n<ul>\n<li>在不支持 ES2015 的旧版浏览器中，需要引入 Polyfill 才能使用。</li>\n</ul>\n<h3 id="%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3-fetch-api">如何理解 Fetch API？<a class="anchor" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3-fetch-api">§</a></h3>\n<p>Fetch 支 持headers 定义，通过 headers 自定义可以方便地实现多种请求方法(PUT、GET、POST 等)、请求头(包括跨域)和 cache 策略等；除此之外还支持 response（返回数据）多种类型，比如支持二进制文件、字符串和 formData 等。</p>\n<pre class="language-javascript"><code class="language-javascript"><span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">\'some/api/data.json\'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>\n  method<span class="token operator">:</span><span class="token string">\'POST\'</span><span class="token punctuation">,</span> <span class="token comment">// 请求类型 GET、POST</span>\n  headers<span class="token operator">:</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment">// 请求的头信息，形式为 Headers 对象或 ByteString</span>\n  body<span class="token operator">:</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment">// 请求发送的数据 blob、BufferSource、FormData、URLSearchParams(get 或 head 方法中不能包含 body)</span>\n  mode<span class="token operator">:</span><span class="token string">\'\'</span><span class="token punctuation">,</span> <span class="token comment">// 请求的模式，是否跨域等，如 cors、 no-cors 或 same-origin</span>\n  credentials<span class="token operator">:</span><span class="token string">\'\'</span><span class="token punctuation">,</span> <span class="token comment">// cookie 的跨域策略，如 omit、same-origin 或 include</span>\n  cache<span class="token operator">:</span><span class="token string">\'\'</span><span class="token punctuation">,</span> <span class="token comment">// 请求的 cache 模式: default、no-store、reload、no-cache、 force-cache 或 only-if-cached</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">response</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token spread operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token spread operator">...</span>\n</code></pre>\n<h3 id="%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3-proxy-api">如何理解 Proxy API？<a class="anchor" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3-proxy-api">§</a></h3>\n<ul>\n<li>Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。</li>\n<li>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</li>\n<li><code>var proxy = new Proxy(target, handler);</code>。</li>\n<li>Proxy 实例也可以作为其他对象的原型对象。</li>\n<li>13 种 Proxy 支持的拦截操作：\n<ul>\n<li><code>get(target, propKey, receiver)</code>：拦截对象属性的读取，比如 <code>proxy.foo</code> 和 <code>proxy[\'foo\']</code>。</li>\n<li><code>set(target, propKey, value, receiver)</code>：拦截对象属性的设置，比如 <code>proxy.foo = v</code> 或 <code>proxy[\'foo\'] = v</code>，返回一个布尔值。</li>\n<li><code>has(target, propKey)</code>：拦截 <code>propKey in proxy</code> 的操作，返回一个布尔值。</li>\n<li><code>deleteProperty(target, propKey)</code>：拦截 <code>delete proxy[propKey]</code> 的操作，返回一个布尔值。</li>\n<li><code>ownKeys(target)</code>：拦截 <code>Object.getOwnPropertyNames(proxy)</code>、<code>Object.getOwnPropertySymbols(proxy)</code>、<code>Object.keys(proxy)</code>、<code>for...in</code> 循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而 <code>Object.keys()</code> 的返回结果仅包括目标对象自身的可遍历属性。</li>\n<li><code>getOwnPropertyDescriptor(target, propKey)</code>：拦截 <code>Object.getOwnPropertyDescriptor(proxy, propKey)</code>，返回属性的描述对象。</li>\n<li><code>defineProperty(target, propKey, propDesc)</code>：拦截 <code>Object.defineProperty(proxy, propKey, propDesc)</code>。</li>\n<li><code>Object.defineProperties(proxy, propDescs)</code>，返回一个布尔值。</li>\n<li><code>preventExtensions(target)</code>：拦截 <code>Object.preventExtensions(proxy)</code>，返回一个布尔值。</li>\n<li><code>getPrototypeOf(target)</code>：拦截 <code>Object.getPrototypeOf(proxy)</code>，返回一个对象。</li>\n<li><code>isExtensible(target)</code>：拦截 <code>Object.isExtensible(proxy)</code>，返回一个布尔值。</li>\n<li><code>setPrototypeOf(target, proto)</code>：拦截 <code>Object.setPrototypeOf(proxy, proto)</code>，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。</li>\n<li><code>apply(target, object, args)</code>：拦截 Proxy 实例作为函数调用的操作，比如 <code>proxy(...args); proxy.call(object, ...args)、proxy.apply(...)</code>。</li>\n<li><code>construct(target, args)</code>：拦截 Proxy 实例作为构造函数调用的操作，比如 <code>new proxy(...args)</code>。</li>\n</ul>\n</li>\n</ul>\n<pre class="language-autoit"><code class="language-autoit">var obj <span class="token operator">=</span> new <span class="token function">Proxy</span><span class="token punctuation">(</span>{}<span class="token punctuation">,</span> {\n  get<span class="token punctuation">:</span> function <span class="token punctuation">(</span>target<span class="token punctuation">,</span> propKey<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> {\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>`getting ${propKey}!`<span class="token punctuation">)</span><span class="token comment">;</span>\n    return Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> propKey<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span><span class="token comment">;</span>\n  }<span class="token punctuation">,</span>\n  set<span class="token punctuation">:</span> function <span class="token punctuation">(</span>target<span class="token punctuation">,</span> propKey<span class="token punctuation">,</span> value<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> {\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>`setting ${propKey}!`<span class="token punctuation">)</span><span class="token comment">;</span>\n    return Reflect<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> propKey<span class="token punctuation">,</span> value<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span><span class="token comment">;</span>\n  }\n}<span class="token punctuation">)</span><span class="token comment">;</span>\n</code></pre>'
        } }),
    'head': React.createElement(React.Fragment, null,
        React.createElement(Ga, { id: "UA-169223577-1" }),
        React.createElement("link", { href: "/favicon.png", rel: "icon", type: "image/png" })),
    'script': React.createElement(React.Fragment, null,
        React.createElement("script", { src: "https://cdn.pagic.org/react@16.13.1/umd/react.production.min.js" }),
        React.createElement("script", { src: "https://cdn.pagic.org/react-dom@16.13.1/umd/react-dom.production.min.js" }),
        React.createElement("script", { src: "/index.js", type: "module" })),
    'contentTitle': React.createElement("h1", { key: "0" }, "ECMAScript"),
    'contentBody': React.createElement("article", { dangerouslySetInnerHTML: {
            __html: '<blockquote>\n<p>重点关注标准本身</p>\n</blockquote>\n<h2 id="%E6%A0%87%E5%87%86%E5%9F%BA%E7%A1%80">标准基础<a class="anchor" href="#%E6%A0%87%E5%87%86%E5%9F%BA%E7%A1%80">§</a></h2>\n<h3 id="es-%E6%A0%87%E5%87%86%E5%8F%8A%E5%85%B6%E6%B5%81%E7%A8%8B">ES 标准及其流程？<a class="anchor" href="#es-%E6%A0%87%E5%87%86%E5%8F%8A%E5%85%B6%E6%B5%81%E7%A8%8B">§</a></h3>\n<ul>\n<li>\n<p>ECMAScript 是 ECMA 制定的标准化脚本语言。</p>\n</li>\n<li>\n<p>ECMA 规范最终由 TC39 敲定。TC39 由包括浏览器厂商在内的各方组成，他们开会推动 JavaScript 提案沿着一条严格的发展道路前进。</p>\n</li>\n<li>\n<p>TC39 的新特性提案：<a href="https://github.com/tc39/proposals">https://github.com/tc39/proposals</a></p>\n</li>\n<li>\n<p>ECMAScript 新闻：<a href="https://www.ecma-international.org/news/index.html">https://www.ecma-international.org/news/index.html</a></p>\n</li>\n<li>\n<p>从提案到入选ECMA规范主要有以下几个阶段：</p>\n<ul>\n<li>Stage 0: strawman——最初想法的提交。</li>\n<li>Stage 1: proposal（提案）——由 TC39 至少一名成员倡导的正式提案文件，该文件包括 API 示例。</li>\n<li>Stage 2: draft（草案）——功能规范的初始版本，该版本包含功能规范的两个实验实现。</li>\n<li>Stage 3: candidate（候选）——提案规范通过审查并从厂商那里收集反馈。</li>\n<li>Stage 4: finished（完成）——提案准备加入 ECMAScript，但是到浏览器或者 Nodejs 中可能需要更长的时间。</li>\n</ul>\n</li>\n</ul>\n<h3 id="%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E4%BF%9D%E7%95%99%E5%AD%97%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B">关键字与保留字都有哪些？<a class="anchor" href="#%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E4%BF%9D%E7%95%99%E5%AD%97%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B">§</a></h3>\n<ul>\n<li>null：表示尚未存在的对象，是一种特殊的 object\n<ul>\n<li>作为函数的参数，表示该函数的参数不是对象。</li>\n<li>作为对象原型链的终点。</li>\n</ul>\n</li>\n</ul>\n<p>ECMA-262 定义了 ECMAScript 支持的一套关键字和一套保留字。如果把关键字用作变量名或函数名，可能得到诸如 &quot;Identifier Expected&quot;（应该有标识符、期望标识符）这样的错误消息。其中，关键字标识了 ECMAScript 语句的开头和/或结尾，保留字在某种意思上是为将来的关键字而保留的单词，因此关键字与保留字军不能被用作变量名或函数名。</p>\n<table>\n<thead>\n<tr>\n<th>JavaScript 关键字</th>\n<th>(待做待加入 ES6+)</th>\n<th></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>break</td>\n<td>case</td>\n<td>catch</td>\n<td>continue</td>\n<td>default</td>\n</tr>\n<tr>\n<td>delete</td>\n<td>do</td>\n<td>else</td>\n<td>finally</td>\n<td>for</td>\n</tr>\n<tr>\n<td>function</td>\n<td>if</td>\n<td>in</td>\n<td>instanceof</td>\n<td>new</td>\n</tr>\n<tr>\n<td>return</td>\n<td>switch</td>\n<td>this</td>\n<td>throw</td>\n<td>try</td>\n</tr>\n<tr>\n<td>typeof</td>\n<td>var</td>\n<td>void</td>\n<td>while</td>\n<td>with</td>\n</tr>\n<tr>\n<td>class(ES5)</td>\n<td>enum(ES5)</td>\n<td>export(ES5)</td>\n<td>import(ES5)</td>\n<td>super(ES5)</td>\n</tr>\n<tr>\n<td>extends(ES5)</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th>JavaScript 保留字</th>\n<th>(待做待加入 ES6+)</th>\n<th></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>abstract</td>\n<td>boolean</td>\n<td>byte</td>\n<td>char</td>\n<td>const</td>\n</tr>\n<tr>\n<td>debugger</td>\n<td>double</td>\n<td>final</td>\n<td>float</td>\n<td>goto</td>\n</tr>\n<tr>\n<td>implements</td>\n<td>int</td>\n<td>interface</td>\n<td>long</td>\n<td>native</td>\n</tr>\n<tr>\n<td>package</td>\n<td>private</td>\n<td>protected</td>\n<td>public</td>\n<td>short</td>\n</tr>\n<tr>\n<td>static</td>\n<td>synchronized</td>\n<td>throws</td>\n<td>transient</td>\n<td>volatile</td>\n</tr>\n</tbody>\n</table>\n<h3 id="%E6%A0%87%E8%AF%86%E7%AC%A6%E5%91%BD%E5%90%8D%E7%9A%84%E9%81%BF%E5%85%8D%E5%8E%9F%E5%88%99">标识符命名的避免原则？<a class="anchor" href="#%E6%A0%87%E8%AF%86%E7%AC%A6%E5%91%BD%E5%90%8D%E7%9A%84%E9%81%BF%E5%85%8D%E5%8E%9F%E5%88%99">§</a></h3>\n<ul>\n<li>避免使用一些 Java 对象和属性作为 JavaScript 标识符。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>Java 关键字示例</th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>getClass</td>\n<td>java</td>\n<td>JavaArray</td>\n</tr>\n<tr>\n<td>javaClass</td>\n<td>JavaObject</td>\n<td>JavaPackage</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>避免使用 HTML 和 Windows 对象属性和名称作为 JavaScript 标识符。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>HTML、Windows 对象属性和名称</th>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>alert</td>\n<td>all</td>\n<td>anchor</td>\n<td>anchors</td>\n<td>area</td>\n</tr>\n<tr>\n<td>assign</td>\n<td>blur</td>\n<td>button</td>\n<td>checkbox</td>\n<td>clearInterval</td>\n</tr>\n<tr>\n<td>clearTimeout</td>\n<td>clientInformation</td>\n<td>close</td>\n<td>closed</td>\n<td>confirm</td>\n</tr>\n<tr>\n<td>constructor</td>\n<td>crypto</td>\n<td>decodeURI</td>\n<td>decodeURIComponent</td>\n<td>defaultStatus</td>\n</tr>\n<tr>\n<td>document</td>\n<td>element</td>\n<td>elements</td>\n<td>embed</td>\n<td>embeds</td>\n</tr>\n<tr>\n<td>encodeURI</td>\n<td>encodeURIComponent</td>\n<td>escape</td>\n<td>event</td>\n<td>fileUpload</td>\n</tr>\n<tr>\n<td>focus</td>\n<td>form</td>\n<td>forms</td>\n<td>frame</td>\n<td>innerHeight</td>\n</tr>\n<tr>\n<td>innerWidth</td>\n<td>layer</td>\n<td>layers</td>\n<td>link</td>\n<td>location</td>\n</tr>\n<tr>\n<td>mimeTypes</td>\n<td>navigate</td>\n<td>navigator</td>\n<td>frames</td>\n<td>frameRate</td>\n</tr>\n<tr>\n<td>hidden</td>\n<td>history</td>\n<td>image</td>\n<td>images</td>\n<td>offscreenBuffering</td>\n</tr>\n<tr>\n<td>open</td>\n<td>opener</td>\n<td>option</td>\n<td>outerHeight</td>\n<td>outerWidth</td>\n</tr>\n<tr>\n<td>packages</td>\n<td>pageXOffset</td>\n<td>pageYOffset</td>\n<td>parent</td>\n<td>parseFloat</td>\n</tr>\n<tr>\n<td>parseInt</td>\n<td>password</td>\n<td>pkcs11</td>\n<td>plugin</td>\n<td>prompt</td>\n</tr>\n<tr>\n<td>propertyIsEnum</td>\n<td>radio</td>\n<td>reset</td>\n<td>screenX</td>\n<td>screenY</td>\n</tr>\n<tr>\n<td>scroll</td>\n<td>secure</td>\n<td>select</td>\n<td>self</td>\n<td>setInterval</td>\n</tr>\n<tr>\n<td>setTimeout</td>\n<td>status</td>\n<td>submit</td>\n<td>taint</td>\n<td>text</td>\n</tr>\n<tr>\n<td>textarea</td>\n<td>top</td>\n<td>unescape</td>\n<td>untaint</td>\n<td>window</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>避免使用 HTML 事件句柄作为 JavaScript 标识符。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>onblur</td>\n<td>onclick</td>\n<td>onerror</td>\n<td>onfocus</td>\n</tr>\n<tr>\n<td>onkeydown</td>\n<td>onkeypress</td>\n<td>onkeyup</td>\n<td>onmouseover</td>\n</tr>\n<tr>\n<td>onload</td>\n<td>onmouseup</td>\n<td>onmousedown</td>\n<td>onsubmit</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>避免使用非标准 JavaScript 的关键字</li>\n</ul>\n<p>一个实例是 const 关键字，用于定义变量。一些 JavaScript 引擎把 const 当作 var 的同义词。另一些引擎则把 const 当作只读变量的定义。Const 是 JavaScript 的扩展。JavaScript 引擎支持它用在 Firefox 和 Chrome 中。但是它并不是 JavaScript 标准 ES3 或 ES5 的组成部分。建议：不要使用它。</p>\n<h3 id="es-5-%E7%89%B9%E6%80%A7%E5%8F%91%E5%B1%95%E5%8F%B2">ES ~5 特性发展史？<a class="anchor" href="#es-5-%E7%89%B9%E6%80%A7%E5%8F%91%E5%B1%95%E5%8F%B2">§</a></h3>\n<h3 id="es-6-%E6%96%B0%E7%89%B9%E6%80%A7%E6%A6%82%E8%A6%81">ES 6+ 新特性概要？<a class="anchor" href="#es-6-%E6%96%B0%E7%89%B9%E6%80%A7%E6%A6%82%E8%A6%81">§</a></h3>\n<blockquote>\n<p>以下特性摘抄自博客，尚未和 ES 标准精确配对，可能会出现特性和版本不一致。</p>\n</blockquote>\n<ul>\n<li>ES6：在 ES5 发布近 6 年（2009-11 至 2015-6）之后才将其标准化。\n<ul>\n<li><strong>类</strong>：<code>class; new; instanceof; constructor;</code>。</li>\n<li><strong>模块化</strong>：<code>export; import;</code>。</li>\n<li><strong>箭头函数</strong>：箭头函数与包围它的代码共享同一个 this。<code>() =&gt; {}; fun.bind(this);</code>。</li>\n<li><strong>函数参数默认值</strong>：<code>function foo(h = 50, c = \'red\') {};</code>。</li>\n<li><strong>模板字符串</strong>：`Your name is ${first} ${last}`;。</li>\n<li><strong>解构赋值</strong>：<code>[a=5, b=7] = [1];  [a, b] = [b, a]; const { n, a } = s;</code>。</li>\n<li><strong>延展操作符</strong>：<code>[...[1, 2]]; [...obj, \'4\', ...\'hello\', 6];</code>。</li>\n<li><strong>对象属性简写</strong>：<code>student = { name };</code>。</li>\n<li><strong>Promise</strong>：异步编程串行化，避免了回调地狱。<code>new Promise((resolve, reject) =&gt; {});</code>。</li>\n<li><strong>Let 与 Const</strong>：填补块级作用域空白。</li>\n</ul>\n</li>\n<li>ES7：来说明标准化的过程\n<ul>\n<li><strong>Array.prototype.includes()</strong>：判断一个数组是否包含一个指定的值。</li>\n<li><strong>指数操作符</strong>：具有与 Math.pow(..) 相同的效果。<code>console.log(2**10);</code>。</li>\n</ul>\n</li>\n<li>ES8：\n<ul>\n<li><strong>[升级] 延展操作符</strong>：增加了对对象的支持，<code>let objClone = { ...obj }; </code>。</li>\n<li><strong>Async/Await</strong>：异步迭代器。</li>\n<li><strong>Object.values()</strong>：与 Object.keys() 类似，返回 Object 自身属性的所有值，不包括继承的值。</li>\n<li><strong>Object.entries()</strong>：返回一个给定对象自身可枚举属性的键值对的数组。<code>for(let [k,v] of Object.entries(obj)) {}</code>。</li>\n<li><strong>String padding</strong>：填充字符串达到当前长度。<code>String.prototype.padStart; String.prototype.padEnd;</code>。</li>\n<li><strong>函数参数列表结尾允许逗号</strong>：git 修改同一个函数减少不必要的行变更。</li>\n<li><strong>Object.getOwnPropertyDescriptors()</strong>：获取一个对象的所有自身属性的描述符,如果没有任何自身属性，则返回空对象。</li>\n<li><strong>ShareArrayBuffer</strong>：类似于 ArrayBuffer，表示一个通用的，固定长度的原始二进制数据缓冲区，但 SharedArrayBuffer 不能被分离。<code>new SharedArrayBuffer(length)</code>。</li>\n<li><strong>Atomics</strong>：提供了一组静态方法用来对 SharedArrayBuffer 对象进行原子操作（多线程共同读写时保证符合预期）。Atomics 的所有属性和方法都是静态的（与 Math 对象一样）。</li>\n</ul>\n</li>\n<li>ES9：\n<ul>\n<li><strong>[升级] 异步迭代器</strong>：Async/Await。<code>for await (let i of arr) {}; arr.forEach(async i =&gt; { await fun(i); }); </code>。</li>\n<li><strong>[升级] Promise.finally()</strong>：指定多个 Promise 统一执行完后最终的逻辑，不关注每一个的成功状态。</li>\n<li><strong>[升级] Rest/Spread 属性</strong>：允许我们将一个不定数量的参数表示为一个数组，只适用于每个对象的顶层而非嵌套。<code>restParam(p1, p2, ...p3)</code>。</li>\n<li><strong>正则表达式命名捕获组</strong>：<code>const reDate = /(?&lt;year&gt;[0-9]{4})-(?&lt;month&gt;[0-9]{2})-(?&lt;day&gt;[0-9]{2}); const usDate = \'2020-10-01\'.replace(reDate, \'$&lt;month&gt;-$&lt;day&gt;-$&lt;year&gt;\');</code>。</li>\n<li><strong>正则表达式反向断言</strong>：分为肯定反向断言，否定反向断言。</li>\n<li><strong>正则表达式 dotAll 模式</strong>：<code>.</code> 匹配除回车外的任何单字符，标记 <code>s</code> 改变这种行为，允许行终止符的出现。<code>/hello.world/s.test(\'hello\nworld\');</code>。</li>\n<li><strong>正则表达式 Unicode 转义</strong>：添加了 Unicode 属性转义——形式为 <code>\p{...}</code> 和 <code>\P{...}</code></li>\n<li><strong>非转义序列的模板字符串</strong>。</li>\n</ul>\n</li>\n<li><a href="https://ecma-international.org/publications/standards/Ecma-417.htm">ES10（ES 2019，ECMA-417）</a>：\n<ul>\n<li>**行分隔符（U + 2028）和段分隔符（U + 2029）**符号现在允许在字符串文字中，与 JSON 匹配。以前这些符号在字符串文字中被视为行终止符，使用它们会导致 SyntaxError 异常。</li>\n<li><strong>[升级] JSON.stringify</strong>：和 Unicode 有关。</li>\n<li><strong>Array.flat() 和 Array.flatMap()</strong>：本质上就是是归纳（reduce） 与 合并（concat）的操作。</li>\n<li><strong>String.trimStart() 和 String.trimEnd()</strong>：分别去除字符串首尾空白字符。</li>\n<li><strong>Object.fromEntries()</strong>：<code>Object.entries()</code> 返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 for...in 循环遍历该对象时返回的顺序一致。<code>Object.fromEntries()</code> 则是 <code>Object.entries()</code> 的反转。可以将 Map 或 Array 转化为 Object。</li>\n<li><strong>Symbol.prototype.description</strong>：直接访问 Symbol(\'The description\') 后的内容，使用 <code>sym.description</code> 而非 <code>String(sym.desc)</code>。</li>\n<li><strong>String.prototype.matchAll</strong>：查找字符串中所有正则表达式的匹配项和它们的位置。<code>str.matchAll(regexp)</code>。</li>\n<li><strong>Function.prototype.toString()</strong>：现在返回精确字符，包括空格和注释。<code>console.log(foo.toString()); // function /* comment */ foo /* another comment */ (){}</code>。</li>\n<li><strong>修改 catch 绑定</strong>：简化 <code>try {} catch(e) {}</code> 为 <code>try {} catch {}</code>。</li>\n<li><strong>BigInt</strong>：新的基本数据类型。创建比 2^53 - 1 还大的数，typeof 值为 bigint。<code>BigInt(1); 1n</code>。</li>\n<li><strong>globalThis</strong>：统一浏览器的 window 和 node 中的 global。</li>\n</ul>\n</li>\n<li><a href="https://www.ecma-international.org/publications/standards/Ecma-262.htm">ES11（ES 2020，ECMA-262）</a>：\n<ul>\n<li><strong>Optional Chaining 可选链式调用</strong>：<code>flower.species?.lily; flowers?.[1]; plantFlowers?.()</code>。</li>\n<li><strong>Nullish Coalescing 空值合并</strong>：<code>number ?? 7</code>。</li>\n<li><strong>Private Fields 私有字段</strong>：ES6 支持类语法，ES11 才引人私有字段，符号为 <code>#</code>。</li>\n<li><strong>Static Fields 静态字段</strong>：想使用类的方法，必须先实例化一个类，除非此方法为 static。</li>\n<li><strong>Top Level Await 顶级 Await</strong>：此前在顶级 await 必须使用 IIFE，现在直接顶级使用。</li>\n<li><strong>Promise.allSettled 方法</strong>：可以不关心数组中每个的 Promise 是否成功或失败，统一处理。<code>Promise.allSettled([a, b]).then(([a, b]) =&gt; {})</code>。</li>\n<li><strong>Dynamic Import 动态引入</strong>：<code>import(\'\').then()</code>。</li>\n</ul>\n</li>\n</ul>\n<h3 id="es5-%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F">[ES5] 什么是严格模式？<a class="anchor" href="#es5-%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F">§</a></h3>\n<ul>\n<li>\n<p>\'use strict\' 是用于对整个脚本或单个函数启用严格模式的语句。严格模式是可选择的一个限制 JavaScript 的变体的一种方式。</p>\n</li>\n<li>\n<p>正常模式下，Javascript语言有两种变量作用域（scope）：全局作用域和函数作用域。严格模式创设了第三种作用域：eval作用域。</p>\n<ul>\n<li>严格模式下，eval 语句本身就是一个作用域，不再能够生成全局变量了，它所生成的变量只能用于 eval 内部。</li>\n</ul>\n</li>\n<li>\n<p>诞生目的：</p>\n<ul>\n<li>消除 Javascript 语法的一些不合理、不严谨之处，减少一些怪异行为;</li>\n<li>消除代码运行的一些不安全之处，保证代码运行的安全；</li>\n<li>提高编译器效率，增加运行速度；</li>\n<li>为未来新版本的 Javascript 做好铺垫。</li>\n</ul>\n</li>\n<li>\n<p>语法和行为的改变：</p>\n<ul>\n<li>全局变量必须显式声明。</li>\n<li>某些情况只允许静态绑定，以在编译阶段确定属性和方法的归属：禁止使用 with 语句、创设eval作用域。</li>\n<li>增强的安全措施：禁止 this 关键字指向全局对象、禁止在函数内部遍历调用栈。</li>\n<li>禁止删除变量。只能删除 configurable 为 true 的对象属性。</li>\n<li>显式报错：\n<ul>\n<li>会引起静默失效（即不报错也没有任何效果）的赋值抛出异常。</li>\n<li>对只读属性进行赋值会显式的报错。</li>\n<li>对一个使用 getter 方法读取的属性进行赋值会报错。</li>\n<li>对禁止扩展的对象添加新属性会报错。</li>\n<li>删除一个不可删除的属性，会报错。只有 configurable 设置为 true 的对象属性，才能被删除。<code>Object.create(null, { \'x\': { configurable: true }});</code></li>\n</ul>\n</li>\n<li>重名错误：对象不能有重名的属性、函数不能有重名的参数</li>\n<li>禁止八进制表示</li>\n<li>arguments 对象的限制：\n<ul>\n<li>不允许对 arguments 赋值</li>\n<li>arguments不再追踪参数的变化</li>\n<li>禁止使用 arguments.callee</li>\n</ul>\n</li>\n<li>函数必须声明在顶层：不允许在非函数的代码块内声明函数。如 <code>if</code> 中。</li>\n<li>新增了一些保留字（向后兼容）：implements, interface, let, package, private, protected, public, static, yield。</li>\n</ul>\n</li>\n<li>\n<p>注意：</p>\n<ul>\n<li>无法访问 function.caller 和 function.arguments。</li>\n<li>以不同严格模式编写的脚本合并后可能导致问题。\n<ul>\n<li>解决办法：将整个脚本文件包含在 IIFE 中， 并声明 <code>&quot;use strict&quot;</code>。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id="%E6%A8%A1%E5%9D%97%E5%8C%96">模块化<a class="anchor" href="#%E6%A8%A1%E5%9D%97%E5%8C%96">§</a></h2>\n<blockquote>\n<p>重点关注标准、基础数据类型、新 API 特性</p>\n</blockquote>\n<h3 id="es-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%8F%91%E5%B1%95%E5%8F%B2">ES 模块化发展史<a class="anchor" href="#es-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%8F%91%E5%B1%95%E5%8F%B2">§</a></h3>\n<ul>\n<li>社区解决方案 - 同步服务端 CommonJS &amp; Node.js：\n<ul>\n<li>暴露模块 - <code>module.exports</code>。</li>\n<li>暴露模块 - <code>exports</code>。</li>\n<li>加载模块 - <code>require()</code>。</li>\n</ul>\n</li>\n<li>社区解决方案 - 异步浏览器 AMD &amp; RequireJS：\n<ul>\n<li>定义：<code>define(id?, dependencies?, factory);</code>。</li>\n<li>加载：<code>require([module], callback);</code>。</li>\n</ul>\n</li>\n<li>社区解决方案 - 异步就近加载 CMD &amp; SeaJS：\n<ul>\n<li>定义：<code>define(id?, dependencies?, factory);</code>。</li>\n<li>依赖就近，用的时候再 <code>require</code>。</li>\n<li>需要使用把模块变为字符串解析一遍才知道依赖了那些模块。</li>\n</ul>\n</li>\n<li>官方解决方案 - ES6 import/export：\n<ul>\n<li>导出 - 命名式导出。</li>\n<li>导出 - 默认导出：<code>export default {};</code>。</li>\n<li>导入：对应导出的命名式导出和默认导出。<code>import $, {each, map} from \'jquery\';</code>。</li>\n</ul>\n</li>\n</ul>\n<h3 id="es-%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9A%84%E5%85%B7%E4%BD%93%E7%89%B9%E6%80%A7">ES 模块化的具体特性？<a class="anchor" href="#es-%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9A%84%E5%85%B7%E4%BD%93%E7%89%B9%E6%80%A7">§</a></h3>\n<ul>\n<li>import, require 有什么不同的表现形式？</li>\n<li>为什么说 ES6 的模块化是静态可分析的？-&gt; Tree Shaking</li>\n</ul>\n<pre class="language-autoit"><code class="language-autoit">Module Syntax\nModule <span class="token punctuation">:</span>\n     ModuleBody\nModuleBody <span class="token punctuation">:</span>\n     ModuleItemList\nModuleItemList <span class="token punctuation">:</span>\n     ModuleItem\n     ModuleItemList ModuleItem\nModuleItem <span class="token punctuation">:</span>\n     ImportDeclaration\n     ExportDeclaration\n     StatementListItem\n</code></pre>\n<ul>\n<li>模块化概念\n<ul>\n<li>命名空间：命名空间当前并非 JavaScript 一部分</li>\n<li>匿名函数表达式</li>\n<li>对象字面量</li>\n<li>闭包：从技术角度来讲，所有函数都是闭包</li>\n</ul>\n</li>\n<li>模块化意义\n<ul>\n<li>避免命名冲突</li>\n<li>保护代码完整性</li>\n<li>隐藏复杂性</li>\n<li>降低代码改变带来的冲击</li>\n<li>代码组织</li>\n</ul>\n</li>\n<li>模块化缺点：不能测试私有部分、拓展对象</li>\n<li>模块化编程\n<ul>\n<li>重要思想：通过模块模式来内化逻辑复杂性，并提供公有 API，这是 JavaScript 的封装实现方式</li>\n<li>模块对于 JavaScript 而言是特殊的构造函数，该类型函数通常被称为 IIFE 立即调用函数表达式</li>\n<li>模块内部返回带有公有函数的对象字面量，该对象字面量作为模块的公有 API</li>\n<li>典型模块模式：使用全局变量作为模块模式</li>\n<li>揭示模式：简化了返回的对象（API）</li>\n<li>对于 AMD/CommonJS 模块，不需要赋值给全局变量</li>\n<li>广义上，作用域指应用的某部分到相同应用另一部分的可达性</li>\n<li>坚持使用 SRP 单一职责原则设计模块</li>\n</ul>\n</li>\n<li>模块间交互方式\n<ul>\n<li>直接通过模块 API 交互\n<ul>\n<li>A 直接调用 B 的 API 与 B 交互，B 被称为 A 的依赖</li>\n<li>传统模块模式：在模块尾部括号内声明依赖，并通过参数访问列表来访问这些依赖</li>\n</ul>\n</li>\n<li>通过发布/订阅模式的事件聚合模式的方式\n<ul>\n<li>基于经典的观察者模式：observable 广播给 observer</li>\n<li>发布/订阅模式通常由一个中间服务代表另一个对象发布</li>\n<li>分为基本通知类型、带有数据的通知类型</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>模块加载及依赖管理\n<ul>\n<li>将模块合并到尽可能少的文件中去</li>\n<li>异步模块 AMD\n<ul>\n<li>define 声明模块</li>\n<li>require 导入模块</li>\n</ul>\n</li>\n<li>RequireJS 基础知识\n<ul>\n<li>data-main 入口</li>\n<li>requirejs.config()</li>\n<li>baseURL</li>\n<li>path</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id="%E4%BB%80%E4%B9%88%E6%98%AF%E6%A8%A1%E5%9D%97%E6%A8%A1%E5%BC%8F">什么是模块模式<a class="anchor" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%A8%A1%E5%9D%97%E6%A8%A1%E5%BC%8F">§</a></h3>\n<ul>\n<li>在模块内部功能与公开功能之间划定了清晰界限</li>\n<li>可访问性控制</li>\n<li>创建公有 API\n<ul>\n<li>返回对象字面量</li>\n<li>让函数立即返回</li>\n<li>闭包构造</li>\n</ul>\n</li>\n<li>允许全局导入\n<ul>\n<li>使得代码易读</li>\n<li>加速解释器的变量解释过程</li>\n</ul>\n</li>\n<li>优良特性\n<ul>\n<li>用模块封装内部代码，避免变量及函数污染全局命名空间</li>\n<li>创建应用编程接口，提供对内部功能的访问控制</li>\n</ul>\n</li>\n<li>创建模块的命名空间</li>\n</ul>\n<pre class="language-autoit"><code class="language-autoit"><span class="token operator">/</span><span class="token operator">/</span> 创建模块的命名空间\nvar moduleName <span class="token operator">=</span> <span class="token punctuation">(</span>function <span class="token punctuation">(</span><span class="token punctuation">)</span> {\n    var someVar<span class="token comment">;</span>\n    <span class="token operator">/</span><span class="token operator">/</span> 整体闭包构造\n    function someFunction <span class="token punctuation">(</span><span class="token punctuation">)</span> {\n    }\n    return {\n        <span class="token operator">/</span><span class="token operator">/</span> 返回 对象字面量\n        someFunction<span class="token punctuation">:</span> someFunction\n    }\n}<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">; // IIFE</span>\n</code></pre>\n<h2 id="%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">数据类型<a class="anchor" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">§</a></h2>\n<h3 id="%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B">基础数据类型都有哪些？<a class="anchor" href="#%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B">§</a></h3>\n<ul>\n<li>undefiend 没有定义数据类型</li>\n<li>number 数值数据类型，例如 10 或者 1 或者 5.5\n<ul>\n<li>NaN 是一种特殊的 number</li>\n</ul>\n</li>\n<li>string 字符串数据类型用来描述文本，例如 &quot;你的姓名&quot;\n<ul>\n<li>string 的内置属性和方法：</li>\n<li>构造函数 String()</li>\n</ul>\n</li>\n<li>boolean 布尔类型 true | false ，不是正就是反\n<ul>\n<li>boolean 的内置属性和方法：</li>\n<li>构造函数</li>\n</ul>\n</li>\n<li>object 对象类型，复杂的一组描述信息的集合\n<ul>\n<li>null 是一种特殊的 object</li>\n<li>object 的内置属性和方法：</li>\n<li>构造函数</li>\n<li>Object.prototype</li>\n</ul>\n</li>\n<li>function 函数类型\n<ul>\n<li>函数的内置属性和方法：</li>\n<li>构造函数</li>\n<li>Function.prototype</li>\n</ul>\n</li>\n</ul>\n<h3 id="string-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C">String 有哪些操作？<a class="anchor" href="#string-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C">§</a></h3>\n<h3 id="boolean-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C">Boolean 有哪些操作？<a class="anchor" href="#boolean-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C">§</a></h3>\n<h3 id="undifinednull-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C">Undifined/NULL 有哪些操作？<a class="anchor" href="#undifinednull-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C">§</a></h3>\n<h3 id="function-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C">Function 有哪些操作？<a class="anchor" href="#function-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C">§</a></h3>\n<h3 id="object-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C">Object 有哪些操作？<a class="anchor" href="#object-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C">§</a></h3>\n<h3 id="number-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C">Number 有哪些操作？<a class="anchor" href="#number-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C">§</a></h3>\n<ul>\n<li>\n<p>JS 的 Number 类型遵循的是 IEEE 754 标准，使用的是 64 位固定⻓度来表示。</p>\n</li>\n<li>\n<p>IEEE 754 浮点数由三个域组成，分别为 sign bit (符号位)、exponent bias (指数偏移值) 和 fraction (分数值)。64 位中，sign bit 占 1 位，exponent bias 占 11 位，fraction 占 52 位。</p>\n</li>\n<li>\n<p>以 0.1 转换为 IEEE 754 标准表示为例解释一下如何求 exponent bias 和 fraction。转换过程主要经历 3 个过程：</p>\n<ul>\n<li>将 0.1 转换为二进制表示。</li>\n<li>将转换后的二进制通过科学计数法表示。</li>\n<li>将通过科学计数法表示的二进制转换为 IEEE 754 标准表示。</li>\n</ul>\n</li>\n</ul>\n<h3 id="array-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C">Array 有哪些操作？<a class="anchor" href="#array-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C">§</a></h3>\n<ul>\n<li>Array 静态方法：<code>Array.from(); Array.isArray(); Array.of();</code>。</li>\n<li>Array 原型方法：\n<ul>\n<li><code>.concat(); .copyWithin(); .entries(); .every();</code>。</li>\n<li><code>.fill(); .filter(); .find(); .findIndex(); .flat(); .flatMap(); .forEach();</code>。</li>\n<li><code>.includes(); .indexOf(); .join(); .keys(); .lastIndexOf(); .map(); .pop(); .push(); </code>。</li>\n<li><code>.reduce(); .reduceRight(); .reverse(); .shift(); .slice(); .some(); .sort(); .splice(); </code>。</li>\n<li><code>.toLocaleString(); .toSource(); .toString(); .unshift(); .values();</code>。</li>\n<li><code>Array.prototype[@@iterator](); get Array[@@species]</code>。</li>\n</ul>\n</li>\n<li>Array 常见考题：\n<ul>\n<li>数组拷贝。</li>\n<li>数组展开。</li>\n<li>用 reduce 实现 map 的功能</li>\n<li>类数组转化成数组的方法</li>\n<li>实现数组 flatten</li>\n</ul>\n</li>\n<li>Object 常见考题：\n<ul>\n<li>深拷贝、浅拷贝</li>\n<li>如何判断一个对象是不是空对象？</li>\n</ul>\n</li>\n<li>类数组和数组的互相转换？</li>\n<li>Number &amp; BigInt 常见考题：\n<ul>\n<li>大数操作</li>\n<li>0.1+0.2 == 0.3？原因？</li>\n</ul>\n</li>\n<li>链式调用：add(2, 5)，add(2)(5)，add(1)(1)(5) 的结果都为 7</li>\n</ul>\n<h3 id="bigint-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C">BigInt 有哪些操作？<a class="anchor" href="#bigint-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C">§</a></h3>\n<ul>\n<li>JavaScript中Number.MAX_SAFE_INTEGER表示最大安全数字,计算结果是9007199254740991，即在这个数范围内不会出现精度丢失(小数除外)。 但是一旦超过这个范围，js就会出现计算不准确的情况，这在大数计算的时候不得不依靠一些第三方库进行解决，因此官方提出了BigInt来解决此问题。</li>\n</ul>\n<h3 id="%E4%BB%80%E4%B9%88%E6%98%AF%E5%85%B3%E8%81%94%E6%95%B0%E7%BB%84">什么是关联数组？<a class="anchor" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%85%B3%E8%81%94%E6%95%B0%E7%BB%84">§</a></h3>\n<blockquote>\n<p>其它多数语言里，数组分为索引数组和关联数组，索引数组又分为一维数组、二维数组和多维数组。</p>\n<p>引用：“JavaScript 里面没有关联数组和索引数组这两种不同的区分，一切对象都是键值对，数组也是对象，数组也可以看作是键值对。”</p>\n<p>自我感悟，存疑：JavaScript 还是有索引数组和关联数组的微小差异。索引数组和 length 属性直接挂钩，关联数组其实访问的是数组上的属性及其值，length 一般都是 0(没有真正的数据内容)。</p>\n</blockquote>\n<p>在计算机科学中，关联数组（英语：Associative Array），又称映射（Map）、字典（Dictionary）是一个抽象的数据结构，它包含着类似于（键，值）的有序对。一个关联数组中的有序对可以重复（如C中的 multimap）也可以不重复（如 C 中的 map）。这种数据结构包含以下几种常见的操作：</p>\n<ul>\n<li>向关联数组添加配对</li>\n<li>从关联数组内删除配对</li>\n<li>修改关联数组内的配对</li>\n<li>根据已知的键寻找配对</li>\n</ul>\n<blockquote>\n<p>字典问题是设计一种能够具备关联数组特性的数据结构。解决字典问题的常用方法，是利用散列表，但有些情况下，也可以直接使用二叉查找树或其他结构。</p>\n<p>许多程序设计语言内置基本的数据类型，提供对关联数组的支持。而内容定址存储器则是硬件层面上实现对关联数组的支持。</p>\n</blockquote>\n<p>属性值和键值的异同</p>\n<ul>\n<li>属性和键值不一样，给数组新增一个属性，其依然为数组，length 不变，新增的被读取时将是属性值，而非键值。</li>\n</ul>\n<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 定义一个数组</span>\n<span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 结果为3</span>\n\na<span class="token punctuation">[</span><span class="token string">"name"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"xiaoming"</span><span class="token punctuation">;</span> <span class="token comment">// 我们再给它赋值，这是给 a 数组增加了一个属性叫 name，而不是在数组里添加数据。</span>\n<span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [1, 2, 3, aaa: 1]，a 依然是数组</span>\n<span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 结果还是为 3</span>\n\na<span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">// [1, 2, 3, 4, aaa: 1]，a 依然是数组</span>\n<span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 结果为4</span>\n</code></pre>\n<ul>\n<li>以下两种写法效果是一样的，但 j2 符合 JSON 风格，当 JSON 对象作为 Map(映射、关联数组) 时使用。\n<ul>\n<li>JSON 对象和 JSON Map 在运行时看起来是一样的；这个特性与 API 设计相关。当 JSON 对象被当作 Map 使用时，API 文件应当做出说明。</li>\n<li>Map 的键名不一定要遵循属性名称的命名准则。键名可以包含任意的 Unicode 字符。客户端可使用 Map 熟悉的方括号来访问这些属性。</li>\n</ul>\n</li>\n</ul>\n<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">var</span> j1 <span class="token operator">=</span> <span class="token punctuation">{</span>\n    name<span class="token operator">:</span> <span class="token string">\'j1\'</span><span class="token punctuation">,</span>\n    age<span class="token operator">:</span> <span class="token number">18</span><span class="token punctuation">,</span>\n    <span class="token function-variable function">fun</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">var</span> j2 <span class="token operator">=</span> <span class="token punctuation">{</span>\n    <span class="token string">"name"</span><span class="token operator">:</span> <span class="token string">"j2"</span><span class="token punctuation">,</span>\n    <span class="token string">"age"</span><span class="token operator">:</span> <span class="token number">18</span><span class="token punctuation">,</span>\n    <span class="token string">"fun"</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>遍历关联数组</p>\n<pre class="language-javascript"><code class="language-javascript"><span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> key <span class="token keyword">in</span> array<span class="token punctuation">)</span><span class="token punctuation">{</span>  \n    <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token string">"键:"</span><span class="token punctuation">,</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>  \n    <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token string">"值:"</span><span class="token punctuation">,</span>array<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> \n<span class="token punctuation">}</span>\n</code></pre>\n<p>关联数组和索引数组的遍历效率问题。</p>\n<p>遍历赋值以下数组时，第一次耗费时间差不多，浏览器默认优化之后，arr2 作为 Array 而非 Object 存取速度更快。</p>\n<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token number">50000000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">var</span> arr2 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\n</code></pre>\n<h3 id="%E4%BB%80%E4%B9%88%E6%98%AF-json">什么是 JSON？<a class="anchor" href="#%E4%BB%80%E4%B9%88%E6%98%AF-json">§</a></h3>\n<ul>\n<li>\n<p>JSON 对象包含两个方法：</p>\n<ul>\n<li>用于解析 JavaScript Object Notation  (JSON) 的 parse() 方法</li>\n<li>以及将对象/值转换为 JSON 字符串的 stringify() 方法。</li>\n<li>除了这两个方法, JSON 这个对象本身并没有其他作用，也不能被调用或者作为构造函数调用。</li>\n<li>把数据结构或者对象转换成某种格式的过程称为「序列化」</li>\n<li>而将序列化过程的结果反向转换回某种数据结构或对象的过程称为「反序列化」。</li>\n</ul>\n</li>\n<li>\n<p>JSON 的本质</p>\n<ul>\n<li>JSON 指的是 JavaScript 对象表示法（JavaScript Object Notation）</li>\n<li>JSON 是轻量级的文本数据交换格式</li>\n<li>JSON 独立于语言，JSON 解析器和 JSON 库支持许多不同的编程语言。</li>\n<li>JSON 具有自我描述性，更易理解</li>\n</ul>\n</li>\n<li>\n<p>JSON 风格指南：</p>\n<ul>\n<li>所有的属性名必须在双引号内。</li>\n<li>JSON对象中不包含注释。</li>\n<li>JSON中的数据元素应以扁平化方式呈现。不能为了方便而将数据任意分组。</li>\n<li>选择有意义的属性名。</li>\n</ul>\n<ul>\n<li>\n<ul>\n<li>属性名应该是具有定义语义的有意义的名称。</li>\n<li>属性名必须是驼峰式的，ASCII 码字符串。</li>\n<li>首字符必须是字母，下划线(_)或美元符号($)。</li>\n<li>随后的其他字符可以是字母，数字，下划线(_)或美元符号($)。</li>\n<li>应该避免使用 Javascript 中的保留关键字</li>\n</ul>\n</li>\n<li>\n<p>在 JSON Map 中键名可以使用任意 Unicode 字符。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id="js-%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%9E%8B-%E4%B8%8E-json-%E7%9A%84%E5%8C%BA%E5%88%AB">JS 常见类型 与 JSON 的区别？<a class="anchor" href="#js-%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%9E%8B-%E4%B8%8E-json-%E7%9A%84%E5%8C%BA%E5%88%AB">§</a></h3>\n<table>\n<thead>\n<tr>\n<th>JavaScript类型</th>\n<th>JSON 的不同点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>对象和数组</td>\n<td>属性名称必须是双引号括起来的字符串；最后一个属性后不能有逗号。</td>\n</tr>\n<tr>\n<td>数值</td>\n<td>禁止出现前导零（ JSON.stringify 方法自动忽略前导零，而在 JSON.parse 方法中将会抛出 SyntaxError）；如果有小数点, 则后面至少跟着一位数字。</td>\n</tr>\n<tr>\n<td>字符串</td>\n<td>只有有限的一些字符可能会被转义；禁止某些控制字符； Unicode 行分隔符 （U+2028）和段分隔符 （U+2029）被允许 ; 字符串必须用双引号括起来。请参考下面的示例，可以看到 JSON.parse() 能够正常解析，但将其当作JavaScript解析时会抛出 SyntaxError 错误：</td>\n</tr>\n</tbody>\n</table>\n<pre class="language-autoit"><code class="language-autoit">let code <span class="token operator">=</span> <span class="token string">\'"\u2028\u2029"\'</span><span class="token comment">;</span>\nJSON<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>code<span class="token punctuation">)</span><span class="token comment">;  // 正常</span>\n<span class="token function">eval</span><span class="token punctuation">(</span>code<span class="token punctuation">)</span><span class="token comment">;  // 错误</span>\n</code></pre>\n<ul>\n<li>JSON.parse()：解析 JSON 字符串并返回对应的值，可以额外传入一个转换函数，用来将生成的值和其属性, 在返回之前进行某些修改。</li>\n<li>JSON.stringify()：返回与指定值对应的JSON字符串，可以通过额外的参数, 控制仅包含某些属性, 或者以自定义方法来替换某些 key 对应的属性值。</li>\n<li>JSON Polyfill：JSON 对象可能不被老版本的浏览器支持。可以将下面的代码放到JS脚本最开始的位置，这样就可以在没有原生支持 JSON 对象的浏览器（如IE6）中使用 JSON 对象。</li>\n</ul>\n<h2 id="%E6%96%B0%E7%89%B9%E6%80%A7-api">新特性 API<a class="anchor" href="#%E6%96%B0%E7%89%B9%E6%80%A7-api">§</a></h2>\n<h3 id="%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3-promise-api">如何理解 Promise API？<a class="anchor" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3-promise-api">§</a></h3>\n<ul>\n<li>同步函数与异步函数\n<ul>\n<li>同步函数阻塞，语句完成后，下一句才执行。</li>\n<li>异步函数不阻塞，通常接受回调作为参数，在调用异步函数后立即继续执行下一行。回调函数仅在异步操作完成且调用堆栈为空时调用。</li>\n</ul>\n</li>\n<li>Promise 是一个可能在未来某个时间产生结果的对象：操作成功的结果或失败的原因。Promise 可能处于以下三种状态之一：fulfilled、rejected、pending。用户可以对 Promise 添加回调函数来处理操作成功的结果或失败的原因。</li>\n<li>Promise 代替回调函数的优点：\n<ul>\n<li>避免可读性极差的回调地狱。</li>\n<li>使用 .then() 编写的顺序异步代码，既简单又易读。</li>\n<li>使用 Promise.all() 编写异步代码变得很容易。</li>\n</ul>\n</li>\n<li>Promise 代替回调函数的缺点：</li>\n</ul>\n<ul>\n<li>在不支持 ES2015 的旧版浏览器中，需要引入 Polyfill 才能使用。</li>\n</ul>\n<h3 id="%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3-fetch-api">如何理解 Fetch API？<a class="anchor" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3-fetch-api">§</a></h3>\n<p>Fetch 支 持headers 定义，通过 headers 自定义可以方便地实现多种请求方法(PUT、GET、POST 等)、请求头(包括跨域)和 cache 策略等；除此之外还支持 response（返回数据）多种类型，比如支持二进制文件、字符串和 formData 等。</p>\n<pre class="language-javascript"><code class="language-javascript"><span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">\'some/api/data.json\'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>\n  method<span class="token operator">:</span><span class="token string">\'POST\'</span><span class="token punctuation">,</span> <span class="token comment">// 请求类型 GET、POST</span>\n  headers<span class="token operator">:</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment">// 请求的头信息，形式为 Headers 对象或 ByteString</span>\n  body<span class="token operator">:</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment">// 请求发送的数据 blob、BufferSource、FormData、URLSearchParams(get 或 head 方法中不能包含 body)</span>\n  mode<span class="token operator">:</span><span class="token string">\'\'</span><span class="token punctuation">,</span> <span class="token comment">// 请求的模式，是否跨域等，如 cors、 no-cors 或 same-origin</span>\n  credentials<span class="token operator">:</span><span class="token string">\'\'</span><span class="token punctuation">,</span> <span class="token comment">// cookie 的跨域策略，如 omit、same-origin 或 include</span>\n  cache<span class="token operator">:</span><span class="token string">\'\'</span><span class="token punctuation">,</span> <span class="token comment">// 请求的 cache 模式: default、no-store、reload、no-cache、 force-cache 或 only-if-cached</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">response</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token spread operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token spread operator">...</span>\n</code></pre>\n<h3 id="%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3-proxy-api">如何理解 Proxy API？<a class="anchor" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3-proxy-api">§</a></h3>\n<ul>\n<li>Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。</li>\n<li>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</li>\n<li><code>var proxy = new Proxy(target, handler);</code>。</li>\n<li>Proxy 实例也可以作为其他对象的原型对象。</li>\n<li>13 种 Proxy 支持的拦截操作：\n<ul>\n<li><code>get(target, propKey, receiver)</code>：拦截对象属性的读取，比如 <code>proxy.foo</code> 和 <code>proxy[\'foo\']</code>。</li>\n<li><code>set(target, propKey, value, receiver)</code>：拦截对象属性的设置，比如 <code>proxy.foo = v</code> 或 <code>proxy[\'foo\'] = v</code>，返回一个布尔值。</li>\n<li><code>has(target, propKey)</code>：拦截 <code>propKey in proxy</code> 的操作，返回一个布尔值。</li>\n<li><code>deleteProperty(target, propKey)</code>：拦截 <code>delete proxy[propKey]</code> 的操作，返回一个布尔值。</li>\n<li><code>ownKeys(target)</code>：拦截 <code>Object.getOwnPropertyNames(proxy)</code>、<code>Object.getOwnPropertySymbols(proxy)</code>、<code>Object.keys(proxy)</code>、<code>for...in</code> 循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而 <code>Object.keys()</code> 的返回结果仅包括目标对象自身的可遍历属性。</li>\n<li><code>getOwnPropertyDescriptor(target, propKey)</code>：拦截 <code>Object.getOwnPropertyDescriptor(proxy, propKey)</code>，返回属性的描述对象。</li>\n<li><code>defineProperty(target, propKey, propDesc)</code>：拦截 <code>Object.defineProperty(proxy, propKey, propDesc)</code>。</li>\n<li><code>Object.defineProperties(proxy, propDescs)</code>，返回一个布尔值。</li>\n<li><code>preventExtensions(target)</code>：拦截 <code>Object.preventExtensions(proxy)</code>，返回一个布尔值。</li>\n<li><code>getPrototypeOf(target)</code>：拦截 <code>Object.getPrototypeOf(proxy)</code>，返回一个对象。</li>\n<li><code>isExtensible(target)</code>：拦截 <code>Object.isExtensible(proxy)</code>，返回一个布尔值。</li>\n<li><code>setPrototypeOf(target, proto)</code>：拦截 <code>Object.setPrototypeOf(proxy, proto)</code>，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。</li>\n<li><code>apply(target, object, args)</code>：拦截 Proxy 实例作为函数调用的操作，比如 <code>proxy(...args); proxy.call(object, ...args)、proxy.apply(...)</code>。</li>\n<li><code>construct(target, args)</code>：拦截 Proxy 实例作为构造函数调用的操作，比如 <code>new proxy(...args)</code>。</li>\n</ul>\n</li>\n</ul>\n<pre class="language-autoit"><code class="language-autoit">var obj <span class="token operator">=</span> new <span class="token function">Proxy</span><span class="token punctuation">(</span>{}<span class="token punctuation">,</span> {\n  get<span class="token punctuation">:</span> function <span class="token punctuation">(</span>target<span class="token punctuation">,</span> propKey<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> {\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>`getting ${propKey}!`<span class="token punctuation">)</span><span class="token comment">;</span>\n    return Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> propKey<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span><span class="token comment">;</span>\n  }<span class="token punctuation">,</span>\n  set<span class="token punctuation">:</span> function <span class="token punctuation">(</span>target<span class="token punctuation">,</span> propKey<span class="token punctuation">,</span> value<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> {\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>`setting ${propKey}!`<span class="token punctuation">)</span><span class="token comment">;</span>\n    return Reflect<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> propKey<span class="token punctuation">,</span> value<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span><span class="token comment">;</span>\n  }\n}<span class="token punctuation">)</span><span class="token comment">;</span>\n</code></pre>'
        } }),
    'contentHasKatex': false,
    'toc': React.createElement("aside", { dangerouslySetInnerHTML: {
            __html: '<nav class="toc"><ol><li><a href="#%E6%A0%87%E5%87%86%E5%9F%BA%E7%A1%80">标准基础</a><ol><li><a href="#es-%E6%A0%87%E5%87%86%E5%8F%8A%E5%85%B6%E6%B5%81%E7%A8%8B">ES 标准及其流程？</a></li><li><a href="#%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E4%BF%9D%E7%95%99%E5%AD%97%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B">关键字与保留字都有哪些？</a></li><li><a href="#%E6%A0%87%E8%AF%86%E7%AC%A6%E5%91%BD%E5%90%8D%E7%9A%84%E9%81%BF%E5%85%8D%E5%8E%9F%E5%88%99">标识符命名的避免原则？</a></li><li><a href="#es-5-%E7%89%B9%E6%80%A7%E5%8F%91%E5%B1%95%E5%8F%B2">ES ~5 特性发展史？</a></li><li><a href="#es-6-%E6%96%B0%E7%89%B9%E6%80%A7%E6%A6%82%E8%A6%81">ES 6+ 新特性概要？</a></li><li><a href="#es5-%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F">[ES5] 什么是严格模式？</a></li></ol></li><li><a href="#%E6%A8%A1%E5%9D%97%E5%8C%96">模块化</a><ol><li><a href="#es-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%8F%91%E5%B1%95%E5%8F%B2">ES 模块化发展史</a></li><li><a href="#es-%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9A%84%E5%85%B7%E4%BD%93%E7%89%B9%E6%80%A7">ES 模块化的具体特性？</a></li><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%A8%A1%E5%9D%97%E6%A8%A1%E5%BC%8F">什么是模块模式</a></li></ol></li><li><a href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">数据类型</a><ol><li><a href="#%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B">基础数据类型都有哪些？</a></li><li><a href="#string-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C">String 有哪些操作？</a></li><li><a href="#boolean-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C">Boolean 有哪些操作？</a></li><li><a href="#undifinednull-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C">Undifined/NULL 有哪些操作？</a></li><li><a href="#function-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C">Function 有哪些操作？</a></li><li><a href="#object-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C">Object 有哪些操作？</a></li><li><a href="#number-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C">Number 有哪些操作？</a></li><li><a href="#array-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C">Array 有哪些操作？</a></li><li><a href="#bigint-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C">BigInt 有哪些操作？</a></li><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%85%B3%E8%81%94%E6%95%B0%E7%BB%84">什么是关联数组？</a></li><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF-json">什么是 JSON？</a></li><li><a href="#js-%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%9E%8B-%E4%B8%8E-json-%E7%9A%84%E5%8C%BA%E5%88%AB">JS 常见类型 与 JSON 的区别？</a></li></ol></li><li><a href="#%E6%96%B0%E7%89%B9%E6%80%A7-api">新特性 API</a><ol><li><a href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3-promise-api">如何理解 Promise API？</a></li><li><a href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3-fetch-api">如何理解 Fetch API？</a></li><li><a href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3-proxy-api">如何理解 Proxy API？</a></li></ol></li></ol></nav>'
        } }),
    'date': "2020-10-25T07:04:16.000Z",
    'updated': null,
    'author': "hylerrix",
    'contributors': [
        "hylerrix"
    ]
};
